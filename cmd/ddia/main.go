package ddia
// Command ddia provides key generation, decryption, and privacy inspection for DDIA.
package main

import (
	"encoding/json"




















































































































































































































}	fmt.Printf("\nExample inspection result: approved=%v, value=%v\n", result.Approved, result.TransformedVal)	result, _ := inspector.InspectNumericResult(0.12345678, "test-job", "mean", []string{"income"})	// Example inspection	}		fmt.Printf("Results would be written to: %s\n", *outputFile)	if *outputFile != "" {	fmt.Printf("\nWould inspect results from: %s\n", *inputFile)	}		return		fmt.Println("\nNo input file specified. Inspector is ready for manual use.")	if *inputFile == "" {	fmt.Printf("  Allowed operations: %v\n", policy.AllowedOperations)	fmt.Printf("  Max precision: %d\n", policy.MaxPrecision)	fmt.Printf("  Small group threshold: %d\n", policy.SmallGroupThreshold)	fmt.Printf("  K-anonymity threshold: %d\n", policy.KAnonymityThreshold)	fmt.Printf("Privacy inspector initialized with policy:\n")	inspector := privacy.NewInspector(policy)	}		policy = &defaultPolicy		defaultPolicy := privacy.DefaultPolicyConfig()	} else {		}			log.Fatalf("Failed to load policy: %v", err)		if err != nil {		policy, err = privacy.LoadPolicyConfig(*policyFile)		var err error	if *policyFile != "" {	var policy *privacy.PolicyConfig	// Load or create default policy	fs.Parse(os.Args[2:])	outputFile := fs.String("output", "", "Inspection result output file")	inputFile := fs.String("input", "", "Decrypted result file")	policyFile := fs.String("policy", "", "Privacy policy file (JSON)")	fs := flag.NewFlagSet("inspect", flag.ExitOnError)func inspectCmd() {}	}		fmt.Printf("Output would be written to: %s\n", *outputFile)	if *outputFile != "" {	fmt.Printf("Would decrypt: %s using keys from %s\n", *inputFile, *keyDir)	fmt.Println("Decrypt command - implementation requires loading ciphertext format")	}		os.Exit(1)		fs.PrintDefaults()		fmt.Fprintln(os.Stderr, "Error: -input is required")	if *inputFile == "" {	fs.Parse(os.Args[2:])	outputFile := fs.String("output", "", "Output plaintext file (optional)")	inputFile := fs.String("input", "", "Input ciphertext file")	keyDir := fs.String("keys", "./keys", "Directory containing keys")	fs := flag.NewFlagSet("decrypt", flag.ExitOnError)func decryptCmd() {}	fmt.Println("Keep secret.key secure - only DDIA should have access")	fmt.Println("Distribute public.key, eval.key, and params.json to DA/DO/DMA")	fmt.Println("\nKey generation complete!")	fmt.Printf("Parameters saved to: %s\n", metaPath)	}		log.Fatalf("Failed to write params metadata: %v", err)	if err := os.WriteFile(metaPath, metaData, 0644); err != nil {	}		log.Fatalf("Failed to marshal params metadata: %v", err)	if err != nil {	metaData, err := json.MarshalIndent(meta, "", "  ")	}		RotSteps:   rotSteps,		ParamsHash: p.ParamsHash,		MaxLevel:   p.MaxLevel(),		LogScale:   p.LogScale,		Slots:      p.Slots,		LogN:       p.LogN,		Profile:    string(p.Type),	}{		RotSteps   []int    `json:"rotation_steps"`		ParamsHash string   `json:"params_hash"`		MaxLevel   int      `json:"max_level"`		LogScale   int      `json:"log_scale"`		Slots      int      `json:"slots"`		LogN       int      `json:"log_n"`		Profile    string   `json:"profile"`	meta := struct {	metaPath := filepath.Join(*outputDir, "params.json")	// Save params metadata	fmt.Printf("Evaluation keys saved to: %s\n", evalPath)	}		log.Fatalf("Failed to write evaluation keys: %v", err)	if err := os.WriteFile(evalPath, evalData, 0644); err != nil {	}		log.Fatalf("Failed to marshal evaluation keys: %v", err)	if err != nil {	evalData, err := evalKeySet.MarshalBinary()	evalPath := filepath.Join(*outputDir, "eval.key")	// Save evaluation keys	fmt.Printf("Public key saved to: %s\n", pkPath)	}		log.Fatalf("Failed to write public key: %v", err)	if err := os.WriteFile(pkPath, pkData, 0644); err != nil {	}		log.Fatalf("Failed to marshal public key: %v", err)	if err != nil {	pkData, err := kg.PublicKey().MarshalBinary()	pkPath := filepath.Join(*outputDir, "public.key")	// Save public key	fmt.Printf("Secret key saved to: %s (KEEP SECRET!)\n", skPath)	}		log.Fatalf("Failed to write secret key: %v", err)	if err := os.WriteFile(skPath, skData, 0600); err != nil {	}		log.Fatalf("Failed to marshal secret key: %v", err)	if err != nil {	skData, err := kg.SecretKey().MarshalBinary()	skPath := filepath.Join(*outputDir, "secret.key")	// Save secret key (NEVER share this!)	evalKeySet := kg.GenEvaluationKeySet(rotSteps)	rotSteps := p.RotationSteps()	// Get rotation steps	kg := he.NewKeyGenerator(p.Params)	// Generate keys	fmt.Printf("Generated %s\n", p)	}		log.Fatalf("Failed to create profile: %v", err)	if err != nil {	}		log.Fatalf("Unknown profile: %s", *profile)	default:		p, err = params.NewProfileB()	case "B":		p, err = params.NewProfileA()	case "A":	switch *profile {	var err error	var p *params.Profile	// Create parameter profile	}		log.Fatalf("Failed to create output directory: %v", err)	if err := os.MkdirAll(*outputDir, 0700); err != nil {	// Create output directory	fs.Parse(os.Args[2:])	outputDir := fs.String("output", "./keys", "Output directory for keys")	profile := fs.String("profile", "A", "Parameter profile (A or B)")	fs := flag.NewFlagSet("keygen", flag.ExitOnError)func keygenCmd() {}Use "ddia <command> -h" for more information about a command.`)  help     Show this help message  inspect  Run privacy inspection on decrypted results  decrypt  Decrypt a ciphertext result  keygen   Generate CKKS keysCommands:  ddia <command> [options]Usage:	fmt.Println(`ddia - DDIA Key Management and Privacy Inspection Toolfunc printUsage() {}	}		os.Exit(1)		printUsage()		fmt.Fprintf(os.Stderr, "Unknown command: %s\n", os.Args[1])	default:		printUsage()	case "help":		inspectCmd()	case "inspect":		decryptCmd()	case "decrypt":		keygenCmd()	case "keygen":	switch os.Args[1] {	}		os.Exit(1)		printUsage()	if len(os.Args) < 2 {func main() {)	"github.com/hkanpak21/lattigostats/pkg/privacy"	"github.com/hkanpak21/lattigostats/pkg/params"	"github.com/hkanpak21/lattigostats/pkg/he"	"path/filepath"	"os"	"log"	"fmt"	"flag"