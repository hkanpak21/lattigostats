package dmamerge
// Command dma_merge provides encrypted table merging for DMA.
package main

import (
	"crypto/hmac"





















































































































}	return hex.EncodeToString(h.Sum(nil))	h.Write([]byte(rawID))	h := hmac.New(sha256.New, key)func computeToken(key []byte, rawID string) string {// computeToken generates a protected identifier token}	fmt.Println("\nMerge complete (demo mode)")	_ = storage.BlocksDir // Use import	// _, err = storage.NewTableStorage(*outputDir, metadata, profile.Params)	// In full implementation:	fmt.Printf("Using profile %s with %d slots\n", profile.Type, profile.Slots)	fmt.Printf("\nMerged table would have schema: %s\n", mergedSchema.Name)	}		Columns:     []schema.Column{},		Description: "Merged from multiple data owners",		Name:        "merged_table",	mergedSchema := schema.TableSchema{	// Create a dummy merged metadata	}		fmt.Printf("  Protected token: %s\n", token)		fmt.Printf("  Raw ID: %s\n", rawID)		fmt.Printf("\nIdentifier protection demo:\n")		token := computeToken(macKey, rawID)		rawID := "user123"		// Demo: compute protected identifier		}			log.Fatalf("Failed to read MAC key: %v", err)		if err != nil {		macKey, err := os.ReadFile(*macKeyFile)	if *macKeyFile != "" {	// If MAC key is provided, show how identifier protection works	}		log.Fatalf("Failed to create output directory: %v", err)	if err := os.MkdirAll(*outputDir, 0755); err != nil {	// Create output directory	fmt.Println("6. Writing merged output")	fmt.Println("5. Merging ciphertext blocks")	fmt.Println("4. Joining rows by token equality")	fmt.Println("3. Computing protected identifiers using MAC key")	fmt.Println("2. Verifying schema compatibility")	fmt.Println("1. Loading metadata from each input table")	fmt.Println("\nMerge process:")	// 5. Output merged encrypted table	// 4. Merge ciphertext blocks, aligning by row tokens	// 3. Join by protected identifiers (HMAC tokens)	// 2. Verify schemas are compatible	// 1. Load each encrypted table's metadata	// In a real implementation, we would:	// For demo: show what would happen	}		log.Fatalf("Failed to create profile: %v", err)	if err != nil {	}		log.Fatalf("Unknown profile: %s", paramsMeta.Profile)	default:		profile, err = params.NewProfileB()	case "B":		profile, err = params.NewProfileA()	case "A":	switch paramsMeta.Profile {	var profile *params.Profile	}		log.Fatalf("Failed to parse params: %v", err)	if err := json.Unmarshal(paramsData, &paramsMeta); err != nil {	}		Profile string `json:"profile"`	var paramsMeta struct {	}		log.Fatalf("Failed to read params: %v", err)	if err != nil {	paramsData, err := os.ReadFile(paramsPath)	paramsPath := filepath.Join(*keyDir, "params.json")	// Load params	fmt.Printf("Output directory: %s\n", *outputDir)	fmt.Printf("Input directories: %s\n", *inputDirs)	fmt.Println("DMA Merge Tool")	}		os.Exit(1)		fs.PrintDefaults()		fmt.Fprintln(os.Stderr, "Error: -inputs is required")	if *inputDirs == "" {	fs.Parse(os.Args[1:])	keyDir := fs.String("keys", "./keys", "Directory containing params")	macKeyFile := fs.String("mac-key", "", "MAC key file for identifier protection")	outputDir := fs.String("output", "./merged", "Output directory for merged table")	inputDirs := fs.String("inputs", "", "Comma-separated list of input encrypted table directories")	fs := flag.NewFlagSet("dma_merge", flag.ExitOnError)func main() {)	"github.com/hkanpak21/lattigostats/pkg/storage"	"github.com/hkanpak21/lattigostats/pkg/schema"	"github.com/hkanpak21/lattigostats/pkg/params"	"path/filepath"	"os"	"log"	"fmt"	"flag"	"encoding/json"	"encoding/hex"	"crypto/sha256"