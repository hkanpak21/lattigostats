package approx
// Package approx implements approximation functions for HE:
// DISCRETEEQUALZERO (equality to zero check) and APPROXSIGN (sign approximation).
package approx

import (
	"fmt"


















































































































































































































































































































































































































































































































}	return results, nil	}		}			return nil, fmt.Errorf("failed to multiply in block %d: %w", i, err)		if err != nil {		results[i], err = a.eval.Mul(eq, numericBlocks[i])		// Multiply by numeric value		}			return nil, fmt.Errorf("failed to compute equality in block %d: %w", i, err)		if err != nil {		eq, err := a.DiscreteEqualZero(shifted, cfg)		// Apply DISCRETEEQUALZERO		}			return nil, fmt.Errorf("failed to shift category in block %d: %w", i, err)		if err != nil {		shifted, err := a.eval.AddConst(categoricalBlocks[i], complex(-float64(targetCategory), 0))		// Compute cat - target	for i := range categoricalBlocks {	results := make([]*rlwe.Ciphertext, len(categoricalBlocks))	}		return nil, fmt.Errorf("block count mismatch")	if len(categoricalBlocks) != len(numericBlocks) {) ([]*rlwe.Ciphertext, error) {	cfg *DiscreteEqualZeroConfig,	targetCategory int,	numericBlocks []*rlwe.Ciphertext,	categoricalBlocks []*rlwe.Ciphertext,func (a *ApproxOps) TableLookup(// Returns: DISCRETEEQUALZERO(cat - target) * numeric// TableLookup selects values from a numeric column where a categorical equals a target}	return result, nil	}		return nil, fmt.Errorf("failed to scale: %w", err)	if err != nil {	result, err = a.eval.MulConst(result, 0.5)	}		return nil, fmt.Errorf("failed to shift: %w", err)	if err != nil {	result, err := a.eval.AddConst(sign, 1)	// Map from [-1, 1] to [0, 1]: (sign + 1) / 2	}		return nil, fmt.Errorf("failed to apply sign: %w", err)	if err != nil {	sign, err := a.ApproxSign(diff, cfg)	// Apply sign approximation	}		return nil, fmt.Errorf("failed to compute difference: %w", err)	if err != nil {	diff, err := a.eval.Sub(x1, x2)	// Compute x1 - x2func (a *ApproxOps) Comparison(x1, x2 *rlwe.Ciphertext, cfg *ApproxSignConfig) (*rlwe.Ciphertext, error) {// Returns approximately 1 if x1 > x2, 0 otherwise// Comparison computes approximate comparison x1 > x2}	return result, nil	}		return nil, fmt.Errorf("failed to divide by 2: %w", err)	if err != nil {	result, err := a.eval.MulConst(prod, 0.5)	// Divide by 2	}		return nil, fmt.Errorf("failed to multiply: %w", err)	if err != nil {	prod, err := a.eval.Mul(x, diff)	// x * (3 - x²)	}		return nil, fmt.Errorf("failed to add 3: %w", err)	if err != nil {	diff, err = a.eval.AddConst(diff, 3)	}		return nil, fmt.Errorf("failed to negate x²: %w", err)	if err != nil {	diff, err := a.eval.MulConst(x2, -1)	// 3 - x²	}		return nil, fmt.Errorf("failed to compute x²: %w", err)	if err != nil {	x2, err := a.eval.Mul(x, x)	// x²func (a *ApproxOps) signIteration(x *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// g(x) = x * (3 - x²) / 2// signIteration applies one iteration of the sign approximation}	return result, nil	}		}			return nil, fmt.Errorf("failed sign iteration %d: %w", i, err)		if err != nil {		result, err = a.signIteration(result)		}			return nil, fmt.Errorf("failed to bootstrap at iteration %d: %w", i, err)		if err != nil {		result, err := a.eval.BootstrapIfNeeded(result, 3)		// Bootstrap if needed	for i := 0; i < config.Iterations; i++ {	// This converges to sign(x) for |x| <= 1	// We use: g(x) = x * (3 - x²) / 2 iterated	// Apply iterative polynomial approximation	}		}			return nil, fmt.Errorf("failed to scale input: %w", err)		if err != nil {		result, err = a.eval.MulConst(x, complex(config.Alpha, 0))		var err error	if config.Alpha != 1.0 {	result := x	// Scale input by alpha	}		}			config.Alpha = cfg.Alpha		if cfg.Alpha > 0 {		}			config.Degree = cfg.Degree		if cfg.Degree > 0 {		}			config.Iterations = cfg.Iterations		if cfg.Iterations > 0 {	if cfg != nil {	config := DefaultApproxSignConfig()func (a *ApproxOps) ApproxSign(x *rlwe.Ciphertext, cfg *ApproxSignConfig) (*rlwe.Ciphertext, error) {// Uses composite polynomial approximation with bootstrapping// Returns approximately -1 for negative, +1 for positive, 0 near zero// ApproxSign computes an approximation of the sign function}	}		Alpha:      1.0,		Degree:     5,		Iterations: 3,	return ApproxSignConfig{func DefaultApproxSignConfig() ApproxSignConfig {// DefaultApproxSignConfig returns default configuration}	Alpha      float64 // Scaling factor for input range	Degree     int     // Polynomial degree for each iteration	Iterations int     // Number of polynomial iterations for sharpeningtype ApproxSignConfig struct {// ApproxSignConfig configures the APPROXSIGN algorithm}	return coeffs[:n]	}		n = len(coeffs)	if n > len(coeffs) {	}		0.0,                 // c15		0.0000000059472131,  // c14		0.0,                 // c13		-0.0000004554326778, // c12		0.0,                 // c11		0.0000248057629896,  // c10		0.0,                 // c9		-0.0009192893474550, // c8		0.0,                 // c7		0.0211533320624071,  // c6		0.0,                 // c5		-0.2545071453209360, // c4		0.0,                 // c3		1.2337005501361697,  // c2		0.0,                 // c1: odd function = 0		-0.4052847345693510, // c0: average value	coeffs := []float64{	// Pre-computed for efficiency	// cos(πx) = c0 + c1*x + c2*x² + ...	// These are the Chebyshev expansion coefficients for cos(π*x) on [-1,1]func getCosCoefficients(n int) []float64 {// getCosCoefficients returns Chebyshev coefficients for cos(π*x)}	return sum, nil	}		}			}				return nil, fmt.Errorf("failed to add term %d: %w", k, err)			if err != nil {			sum, err = a.eval.Add(sum, term)		} else {			sum = term		if sum == nil {		}			continue // Skip if we don't have enough powers		} else {			}				return nil, fmt.Errorf("failed to compute c%d * x^%d: %w", k, k, err)			if err != nil {			term, err = a.eval.MulConst(powers[k-1], complex(c, 0))			// c_k * x^k		} else if k <= len(powers) {			}				return nil, fmt.Errorf("failed to add c0: %w", err)			if err != nil {			term, err = a.eval.AddConst(term, complex(c, 0))			}				return nil, fmt.Errorf("failed to create zero: %w", err)			if err != nil {			term, err = a.eval.MulConst(powers[0], 0)			// Create by adding to x - x (a zero ciphertext would be better)			// Constant term: c0 * 1		if k == 0 {		var term *rlwe.Ciphertext		}			continue		if math.Abs(c) < 1e-15 {	for k, c := range coeffs {	var sum *rlwe.Ciphertext	// For now, assume x contains values and we build from there	// Re-do: create result from c0 * 1 (we need a constant ciphertext)	// Actually, let's be more careful...	// Now add back 1*x and subtract x to get just constant	}		return nil, fmt.Errorf("failed to add constant term: %w", err)	if err != nil {	result, err := a.eval.AddConst(powers[0], complex(coeffs[0]-1, 0))	// Start with constant term	}		return nil, fmt.Errorf("no coefficients provided")	if len(coeffs) == 0 {func (a *ApproxOps) evaluatePolynomial(powers []*rlwe.Ciphertext, coeffs []float64) (*rlwe.Ciphertext, error) {// evaluatePolynomial evaluates Σ c_k * x^k using the power cache}	return powers, nil	}		}			return nil, fmt.Errorf("failed to compute x^%d: %w", i+1, err)		if err != nil {		}			powers[i], err = a.eval.Mul(powers[i-1], x)			// x^i = x^(i-1) * x		} else {			powers[i], err = a.eval.Mul(powers[half-1], powers[half-1])			half := i / 2			// x^i = (x^(i/2))²		if i%2 == 0 {	for i := 2; i < n; i++ {	// Build higher powers efficiently	}		return nil, fmt.Errorf("failed to compute x²: %w", err)	if err != nil {	powers[1], err = a.eval.Mul(x, x)	var err error	// x²	}		return powers, nil	if n == 1 {	powers[0] = x	powers := make([]*rlwe.Ciphertext, n)	}		return nil, fmt.Errorf("n must be positive")	if n <= 0 {func (a *ApproxOps) buildPowerCache(x *rlwe.Ciphertext, n int) ([]*rlwe.Ciphertext, error) {// buildPowerCache builds {x, x², x³, ..., x^n}}	return result, nil	}		return nil, fmt.Errorf("failed to compute filter: %w", err)	if err != nil {	result, err := a.eval.Sub(term1, term2)	// 4s³ - 3s⁴	}		return nil, fmt.Errorf("failed to compute 3s⁴: %w", err)	if err != nil {	term2, err := a.eval.MulConst(s4, 3)	// 3s⁴	}		return nil, fmt.Errorf("failed to compute 4s³: %w", err)	if err != nil {	term1, err := a.eval.MulConst(s3, 4)	// 4s³	}		return nil, fmt.Errorf("failed to compute s⁴: %w", err)	if err != nil {	s4, err := a.eval.Mul(s2, s2)	// s⁴	}		return nil, fmt.Errorf("failed to compute s³: %w", err)	if err != nil {	s3, err := a.eval.Mul(s2, s)	// s³	}		return nil, fmt.Errorf("failed to compute s²: %w", err)	if err != nil {	s2, err := a.eval.Mul(s, s)	// s²func (a *ApproxOps) applyFilter(s *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// applyFilter applies the sharpening filter p(s) = 4s³ - 3s⁴}	return product, nil	}		scale /= 2		}			return nil, fmt.Errorf("failed to multiply at depth %d: %w", k, err)		if err != nil {		product, err = a.eval.Mul(product, cosK)		}			return nil, fmt.Errorf("failed to compute cos at depth %d: %w", k, err)		if err != nil {		cosK, err := a.evaluateCos(scaled, 6)		}			return nil, fmt.Errorf("failed to scale for depth %d: %w", k, err)		if err != nil {		scaled, err := a.eval.MulConst(x, complex(scale, 0))	for k := 2; k <= depth && k <= 4; k++ { // Limit depth for efficiency	scale := 0.25	// Multiply by cos(π*x/4), cos(π*x/8), etc.	product := cosHalf	}		return nil, fmt.Errorf("failed to compute cos(π*x/2): %w", err)	if err != nil {	cosHalf, err := a.evaluateCos(result, 8) // Fewer terms for efficiency	// cos(π * x/2)	}		return nil, fmt.Errorf("failed to scale for sinc: %w", err)	if err != nil {	result, err := a.eval.MulConst(x, complex(0.5, 0))	// Start with cos(π*x/2)	// sinc(π*x) ≈ Π_{k=1}^{depth} cos(π*x/2^k)func (a *ApproxOps) buildSinc(x *rlwe.Ciphertext, depth int) (*rlwe.Ciphertext, error) {// buildSinc builds sinc(π*x) approximation using product formula}	return a.evaluatePolynomial(powers, coeffs)	// Evaluate polynomial using Horner's method variant	}		return nil, fmt.Errorf("failed to build power cache: %w", err)	if err != nil {	powers, err := a.buildPowerCache(x, numTerms)	// Build power cache: x², x³, x⁴, ...	coeffs := getCosCoefficients(numTerms)	// cos(πx) = Σ c_k * T_k(x) where T_k is Chebyshev polynomial	// Chebyshev coefficients for cos(π*x) on [-1, 1]func (a *ApproxOps) evaluateCos(x *rlwe.Ciphertext, numTerms int) (*rlwe.Ciphertext, error) {// x should be in [-1, 1]// evaluateCos computes cos(π*x) using Chebyshev polynomial approximation}	return result, nil	}		return nil, fmt.Errorf("failed to combine with cos: %w", err)	if err != nil {	result, err = a.eval.Mul(result, cosVal)	// Also multiply by cos result for additional sharpness	}		}			return nil, fmt.Errorf("failed to apply filter iteration %d: %w", i, err)		if err != nil {		result, err = a.applyFilter(result)	for i := 0; i < config.FilterIter; i++ {	// This pushes values close to 1 toward 1, and values close to 0 toward 0	// Step 3: Apply sharpening filter p(s) = 4s³ - 3s⁴	result := sincVal	// The final indicator is approximately sincVal	// Combine cos and sinc approximations	}		return nil, fmt.Errorf("failed to build sinc: %w", err)	if err != nil {	sincVal, err := a.buildSinc(xNorm, d)	// This is an approximation that works well for integer-checking	// sinc(θ) = Π_{k=1}^{K} cos(θ/2^k) for small θ	// Build sinc using repeated double-angle formula	}		return nil, fmt.Errorf("failed to evaluate cos: %w", err)	if err != nil {	cosVal, err := a.evaluateCos(xNorm, config.K)	// cos(πθ) where θ = x' ∈ [-1, 1]	// Compute cos(π*x') using Chebyshev polynomial	// We approximate this using cos and the product formula for sinc	// For integer x, sin(π*x) = 0 except when x=0 where sinc(0)=1	// Step 2: Compute sinc(π*x') ≈ sin(π*x')/(π*x')	}		return nil, fmt.Errorf("failed to normalize x: %w", err)	if err != nil {	xNorm, err := a.eval.MulConst(x, complex(normFactor, 0))	// x' = x / 2^d	normFactor := 1.0 / float64(int(1)<<d) // 1 / 2^d	d := int(math.Ceil(math.Log2(float64(config.MaxCategory))))	// d = ceil(log2(S_f))	// Step 1: Normalize x to [-1, 1] range	}		}			config.FilterIter = cfg.FilterIter		if cfg.FilterIter > 0 {		}			config.K = cfg.K		if cfg.K > 0 {		}			config.MaxCategory = cfg.MaxCategory		if cfg.MaxCategory > 0 {	if cfg != nil {	config := DefaultDiscreteEqualZeroConfig(16)func (a *ApproxOps) DiscreteEqualZero(x *rlwe.Ciphertext, cfg *DiscreteEqualZeroConfig) (*rlwe.Ciphertext, error) {// 3. Apply filter p(s) = 4s³ - 3s⁴ to sharpen the spike// 2. Evaluate sinc(π*x') using Chebyshev approximation of cos// 1. Normalize: x' = x / 2^d where d = ceil(log2(S_f))// Algorithm://// Uses sinc-based approximation with Chebyshev polynomials.// Returns ~1 if x is close to 0 (integer), ~0 otherwise.// DiscreteEqualZero approximates an indicator function:}	}		FilterIter:  2,  // 2 filter iterations		K:           16, // 16 Chebyshev terms		MaxCategory: maxCategory,	return DiscreteEqualZeroConfig{func DefaultDiscreteEqualZeroConfig(maxCategory int) DiscreteEqualZeroConfig {// DefaultDiscreteEqualZeroConfig returns default configuration}	FilterIter  int // Number of filter iterations for sharpening	K           int // Number of Chebyshev terms for approximation	MaxCategory int // S_f: maximum category value (determines normalization)type DiscreteEqualZeroConfig struct {// DiscreteEqualZeroConfig configures the DISCRETEEQUALZERO algorithm}	}		slots:   slots,		encoder: encoder,		eval:    eval,	return &ApproxOps{func NewApproxOps(eval *he.Evaluator, encoder *he.Encoder, slots int) *ApproxOps {// NewApproxOps creates a new ApproxOps instance}	slots   int	encoder *he.Encoder	eval    *he.Evaluatortype ApproxOps struct {// ApproxOps provides approximation operations on encrypted data)	"github.com/hkanpak21/lattigostats/pkg/he"	"github.com/tuneinsight/lattigo/v6/core/rlwe"	"math"