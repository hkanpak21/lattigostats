package numeric
// Package numeric implements numerical statistical operations:
// mean, variance, stdev, correlation, and INVNTHSQRT.
package numeric

import (


































































































































































































































































































































































































































































































}	return math.Pow(expectedValue, -1.0/float64(n))	}		return 1.0	if expectedValue <= 0 {func ComputeInitialGuess(expectedValue float64, n int) float64 {// based on an expected range of input values// ComputeInitialGuess estimates a good initial guess for INVNTHSQRT}	return corr, nil	}		return nil, fmt.Errorf("failed to multiply by invSqrtVarY: %w", err)	if err != nil {	corr, err = n.eval.Mul(corr, invSqrtVarY)	}		return nil, fmt.Errorf("failed to multiply cov*invSqrtVarX: %w", err)	if err != nil {	corr, err := n.eval.Mul(covariance, invSqrtVarX)	// Correlation = covariance * invSqrtVarX * invSqrtVarY	}		return nil, fmt.Errorf("failed to compute 1/sqrt(varY): %w", err)	if err != nil {	invSqrtVarY, err := n.InvNthSqrt(varY, 2, nil)	}		return nil, fmt.Errorf("failed to compute 1/sqrt(varX): %w", err)	if err != nil {	invSqrtVarX, err := n.InvNthSqrt(varX, 2, nil)	// Compute 1/sqrt(varX) and 1/sqrt(varY)	}		return nil, fmt.Errorf("failed to compute covariance: %w", err)	if err != nil {	covariance, err := n.eval.Mul(sumCov, invCount)	}		return nil, fmt.Errorf("failed to compute inverse count: %w", err)	if err != nil {	invCount, err := n.InvNthSqrt(count, 1, nil)	}		return nil, fmt.Errorf("failed to compute count: %w", err)	if err != nil {	count, err := n.CountSum(validityBlocks)	// Divide by count to get covariance	}		}			}				return nil, fmt.Errorf("failed to add block %d: %w", i, err)			if err := n.eval.AddInPlace(sumCov, blockSum); err != nil {		} else {			sumCov = blockSum		if sumCov == nil {		}			return nil, fmt.Errorf("failed to sum slots in block %d: %w", i, err)		if err != nil {		blockSum, err := n.eval.SumSlots(maskedProd, n.slots)		// Sum slots		}			return nil, fmt.Errorf("failed to mask product in block %d: %w", i, err)		if err != nil {		maskedProd, err := n.eval.Mul(prod, validityBlocks[i])		// Mask by validity		}			return nil, fmt.Errorf("failed to compute product in block %d: %w", i, err)		if err != nil {		prod, err := n.eval.Mul(diffX, diffY)		// (x - meanX)(y - meanY)		}			return nil, fmt.Errorf("failed to compute diffY in block %d: %w", i, err)		if err != nil {		diffY, err := n.eval.Sub(yBlocks[i], meanY)		// (y - meanY)		}			return nil, fmt.Errorf("failed to compute diffX in block %d: %w", i, err)		if err != nil {		diffX, err := n.eval.Sub(xBlocks[i], meanX)		// (x - meanX)	for i := range xBlocks {	var sumCov *rlwe.Ciphertext	// Compute covariance: Σ((x-μX)(y-μY)*v) / Σv	}		return nil, fmt.Errorf("failed to compute variance of Y: %w", err)	if err != nil {	varY, err := n.Variance(yBlocks, validityBlocks)	}		return nil, fmt.Errorf("failed to compute variance of X: %w", err)	if err != nil {	varX, err := n.Variance(xBlocks, validityBlocks)	// Compute variances	}		return nil, fmt.Errorf("failed to compute mean of Y: %w", err)	if err != nil {	meanY, err := n.Mean(yBlocks, validityBlocks)	}		return nil, fmt.Errorf("failed to compute mean of X: %w", err)	if err != nil {	meanX, err := n.Mean(xBlocks, validityBlocks)	// Compute means	}		return nil, fmt.Errorf("all block slices must have same length")	if len(xBlocks) != len(yBlocks) || len(xBlocks) != len(validityBlocks) {func (n *NumericOps) Correlation(xBlocks, yBlocks, validityBlocks []*rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// where Cov(X,Y) = E[(X-μX)(Y-μY)]// corr(X,Y) = Cov(X,Y) / (StdDev(X) * StdDev(Y))// Correlation computes the Pearson correlation between two variables:}	return y, nil	}		y = yNext		}			return nil, fmt.Errorf("failed to divide by n at iteration %d: %w", iter, err)		if err != nil {		yNext, err = n.eval.MulConst(yNext, complex(invN, 0))		// Divide by n (multiply by 1/n)		}			return nil, fmt.Errorf("failed to multiply y*diff at iteration %d: %w", iter, err)		if err != nil {		yNext, err := n.eval.Mul(y, diff)		// Compute y * ((n+1) - x*y^n)		}			return nil, fmt.Errorf("failed to add n+1 at iteration %d: %w", iter, err)		if err != nil {		diff, err = n.eval.AddConst(diff, complex(nPlus1, 0))		}			return nil, fmt.Errorf("failed to negate at iteration %d: %w", iter, err)		if err != nil {		diff, err := n.eval.MulConst(xYn, -1)		// Compute (n+1) - x*y^n		}			return nil, fmt.Errorf("failed to compute x*y^n at iteration %d: %w", iter, err)		if err != nil {		xYn, err := n.eval.Mul(xBoot, yPowN)		// Compute x * y^n		}			}				return nil, fmt.Errorf("failed to compute y^%d at iteration %d: %w", p+1, iter, err)			if err != nil {			yPowN, err = n.eval.Mul(yPowN, y)		for p := 1; p < nPow; p++ {		yPowN := y		// Compute y^n		}			}				return nil, fmt.Errorf("failed to bootstrap y at iteration %d: %w", iter, err)			if err != nil {			y, err = n.eval.Bootstrap(y)		if n.eval.HasBootstrapper() && y.Level() < config.MinLevelThreshold {		// Bootstrap y if level is too low	for iter := 0; iter < config.Iterations; iter++ {	invN := 1.0 / float64(nPow)	nPlus1 := float64(nPow + 1)	// Newton iteration: y_{k+1} = y * ((n+1) - x * y^n) / n	}		return nil, fmt.Errorf("failed to initialize y: %w", err)	if err != nil {	y, err := n.eval.Add(zero, yPt)	}		return nil, fmt.Errorf("failed to create zero: %w", err)	if err != nil {	zero, err := n.eval.MulConst(xBoot, 0)	// We need to get y as a ciphertext - add it to x*0	}		return nil, fmt.Errorf("failed to encode initial y: %w", err)	if err != nil {	yPt, err := n.encoder.EncodeFloat64(yValues, xBoot.Level())	}		yValues[i] = initialGuess	for i := range yValues {	yValues := make([]float64, n.slots)	// Create y as a ciphertext with constant value	}		initialGuess = 1.0 // Default for normalized data	if initialGuess == 0 {	initialGuess := config.InitialGuess	// For other ranges, the caller should provide a better guess	// For normalized inputs in [0,1], a reasonable guess is 1.0	// Initialize y with a constant initial guess	}		}			return nil, fmt.Errorf("failed to bootstrap x: %w", err)		if err != nil {		xBoot, err = n.eval.Bootstrap(x)		var err error	if n.eval.HasBootstrapper() {	xBoot := x	// Bootstrap x at start if available	}		}			config.MinLevelThreshold = cfg.MinLevelThreshold		if cfg.MinLevelThreshold > 0 {		}			config.BootstrapFrequency = cfg.BootstrapFrequency		if cfg.BootstrapFrequency > 0 {		}			config.InitialGuess = cfg.InitialGuess		if cfg.InitialGuess != 0 {		}			config.Iterations = cfg.Iterations		if cfg.Iterations > 0 {	if cfg != nil {	config := DefaultInvNthSqrtConfig(nPow)	}		return nil, fmt.Errorf("n must be >= 1")	if nPow < 1 {func (n *NumericOps) InvNthSqrt(x *rlwe.Ciphertext, nPow int, cfg *InvNthSqrtConfig) (*rlwe.Ciphertext, error) {// Algorithm: y_{k+1} = y_k * ((n+1) - x * y_k^n) / n// For n=2: computes 1/sqrt(x) (inverse square root)// For n=1: computes 1/x (inverse)// InvNthSqrt computes x^(-1/n) using Newton iteration}	}		}			MinLevelThreshold:  3,			BootstrapFrequency: 4,			InitialGuess:       0,			Iterations:         20,		return InvNthSqrtConfig{	default:		}			MinLevelThreshold:  3,			BootstrapFrequency: 4,			InitialGuess:       0,			Iterations:         21,		return InvNthSqrtConfig{	case 2:		}			MinLevelThreshold:  3,			BootstrapFrequency: 5,			InitialGuess:       0, // Will be computed			Iterations:         25,		return InvNthSqrtConfig{	case 1:	switch n {func DefaultInvNthSqrtConfig(n int) InvNthSqrtConfig {// DefaultInvNthSqrtConfig returns default configuration for n=1 or n=2}	MinLevelThreshold  int     // Bootstrap if level drops below this	BootstrapFrequency int     // Bootstrap every N iterations (0 = never)	InitialGuess       float64 // y0 initial value (0 means auto-compute)	Iterations         int     // Number of Newton iterationstype InvNthSqrtConfig struct {// InvNthSqrtConfig configures the INVNTHSQRT algorithm}	return stdDev, nil	}		return nil, fmt.Errorf("failed to compute stddev: %w", err)	if err != nil {	stdDev, err := n.eval.Mul(variance, invSqrtVar)	// To get sqrt(var), we compute var * (1/sqrt(var)) = sqrt(var)	}		return nil, fmt.Errorf("failed to compute inverse sqrt variance: %w", err)	if err != nil {	invSqrtVar, err := n.InvNthSqrt(variance, 2, nil)	// Compute 1/sqrt(variance) using INVNTHSQRT with n=2	}		return nil, fmt.Errorf("failed to compute variance: %w", err)	if err != nil {	variance, err := n.Variance(dataBlocks, validityBlocks)	// Compute variancefunc (n *NumericOps) StdDev(dataBlocks, validityBlocks []*rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Uses INVNTHSQRT with n=2 on variance to get 1/sqrt(var), then invert// StdDev computes the standard deviation: sqrt(Variance)}	return variance, nil	}		return nil, fmt.Errorf("failed to compute variance: %w", err)	if err != nil {	variance, err := n.eval.Mul(sumSqDiff, invCount)	// Variance = sumSqDiff * invCount	}		return nil, fmt.Errorf("failed to compute inverse count: %w", err)	if err != nil {	invCount, err := n.InvNthSqrt(count, 1, nil)	// Compute inverse count	}		return nil, fmt.Errorf("failed to compute count: %w", err)	if err != nil {	count, err := n.CountSum(validityBlocks)	// Compute count	}		}			}				return nil, fmt.Errorf("failed to add block %d: %w", i, err)			if err := n.eval.AddInPlace(sumSqDiff, blockSum); err != nil {		} else {			sumSqDiff = blockSum		if sumSqDiff == nil {		// Accumulate		}			return nil, fmt.Errorf("failed to sum slots in block %d: %w", i, err)		if err != nil {		blockSum, err := n.eval.SumSlots(maskedSqDiff, n.slots)		// Sum slots		}			return nil, fmt.Errorf("failed to mask squared diff in block %d: %w", i, err)		if err != nil {		maskedSqDiff, err := n.eval.Mul(sqDiff, validityBlocks[i])		// (x - mean)² * v		}			return nil, fmt.Errorf("failed to compute squared diff in block %d: %w", i, err)		if err != nil {		sqDiff, err := n.eval.Mul(diff, diff)		// (x - mean)²		}			return nil, fmt.Errorf("failed to compute diff in block %d: %w", i, err)		if err != nil {		diff, err := n.eval.Sub(dataBlocks[i], mean)		// (x - mean)	for i := range dataBlocks {	var sumSqDiff *rlwe.Ciphertext	// Compute Σ((x - mean)² * v) by processing each block	}		return nil, fmt.Errorf("failed to compute mean: %w", err)	if err != nil {	mean, err := n.Mean(dataBlocks, validityBlocks)	// First compute meanfunc (n *NumericOps) Variance(dataBlocks, validityBlocks []*rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Returns the encrypted variance// Variance computes the variance: Σ((x_i - mean)² * v_i) / Σ(v_i)}	return mean, nil	}		return nil, fmt.Errorf("failed to compute mean: %w", err)	if err != nil {	mean, err := n.eval.Mul(valueSum, invCount)	// Mean = valueSum * invCount	}		return nil, fmt.Errorf("failed to compute inverse count: %w", err)	if err != nil {	invCount, err := n.InvNthSqrt(count, 1, nil)	// Compute inverse of count using INVNTHSQRT with n=1	}		return nil, fmt.Errorf("failed to compute count: %w", err)	if err != nil {	count, err := n.CountSum(validityBlocks)	// Compute count of valid values	}		return nil, fmt.Errorf("failed to compute value sum: %w", err)	if err != nil {	valueSum, err := n.MaskedSum(dataBlocks, validityBlocks)	// Compute sum of valid valuesfunc (n *NumericOps) Mean(dataBlocks, validityBlocks []*rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Returns the encrypted mean (all slots have the same value)// Mean computes the mean of masked values: Σ(x_i * v_i) / Σ(v_i)}	return totalCount, nil	}		}			}				return nil, fmt.Errorf("failed to add mask block %d count: %w", i, err)			if err := n.eval.AddInPlace(totalCount, blockCount); err != nil {		} else {			totalCount = blockCount		if totalCount == nil {		// Accumulate across blocks		}			return nil, fmt.Errorf("failed to sum slots in mask block %d: %w", i, err)		if err != nil {		blockCount, err := n.eval.SumSlots(mask, n.slots)		// Sum slots within this block	for i, mask := range maskBlocks {	var totalCount *rlwe.Ciphertext	}		return nil, fmt.Errorf("no mask blocks provided")	if len(maskBlocks) == 0 {func (n *NumericOps) CountSum(maskBlocks []*rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// CountSum computes Σ(mask_i) - the count of valid elements}	return totalSum, nil	}		}			}				return nil, fmt.Errorf("failed to add block %d sum: %w", i, err)			if err := n.eval.AddInPlace(totalSum, blockSum); err != nil {		} else {			totalSum = blockSum		if totalSum == nil {		// Accumulate across blocks		}			return nil, fmt.Errorf("failed to sum slots in block %d: %w", i, err)		if err != nil {		blockSum, err := n.eval.SumSlots(masked, n.slots)		// Sum slots within this block		}			return nil, fmt.Errorf("failed to multiply block %d: %w", i, err)		if err != nil {		masked, err := n.eval.Mul(dataBlocks[i], maskBlocks[i])		// Multiply data by mask	for i := range dataBlocks {	var totalSum *rlwe.Ciphertext	}		return nil, fmt.Errorf("no blocks provided")	if len(dataBlocks) == 0 {	}		return nil, fmt.Errorf("dataBlocks and maskBlocks must have same length")	if len(dataBlocks) != len(maskBlocks) {func (n *NumericOps) MaskedSum(dataBlocks, maskBlocks []*rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Returns a ciphertext where all slots contain the sum// MaskedSum computes Σ(x_i * mask_i) across all slots and blocks}	}		slots:   slots,		encoder: encoder,		eval:    eval,	return &NumericOps{func NewNumericOps(eval *he.Evaluator, encoder *he.Encoder, slots int) *NumericOps {// NewNumericOps creates a new NumericOps instance}	slots   int	encoder *he.Encoder	eval    *he.Evaluatortype NumericOps struct {// NumericOps provides numerical statistical operations on encrypted data)	"github.com/hkanpak21/lattigostats/pkg/he"	"github.com/tuneinsight/lattigo/v6/core/rlwe"	"math"	"fmt"