package categorical
// Package categorical implements categorical statistical operations:
// BMV generation, BIN-OP (Bc/Ba/Bv), and LBc with PBMV/BBMV.
package categorical

import (
	"fmt"


























































































































































































































































































































































































































































































}	return ct.Counts[flatIdx], nil	}		multiplier *= ct.Dimensions[i]		flatIdx += indices[i] * multiplier		}			return 0, fmt.Errorf("index %d out of bounds for dimension %d", indices[i], i)		if indices[i] < 0 || indices[i] >= ct.Dimensions[i] {	for i := len(indices) - 1; i >= 0; i-- {	multiplier := 1	flatIdx := 0	}		return 0, fmt.Errorf("index dimension mismatch")	if len(indices) != len(ct.Dimensions) {func (ct *ContingencyTable) GetCount(indices []int) (int64, error) {// GetCount gets the count at a given multi-dimensional index}	return nil	ct.Counts[flatIdx] = count	}		multiplier *= ct.Dimensions[i]		flatIdx += indices[i] * multiplier		}			return fmt.Errorf("index %d out of bounds for dimension %d", indices[i], i)		if indices[i] < 0 || indices[i] >= ct.Dimensions[i] {	for i := len(indices) - 1; i >= 0; i-- {	multiplier := 1	flatIdx := 0	}		return fmt.Errorf("index dimension mismatch")	if len(indices) != len(ct.Dimensions) {func (ct *ContingencyTable) SetCount(indices []int, count int64) error {// SetCount sets the count at a given multi-dimensional index}	}		Counts:     make([]int64, total),		Dimensions: dimensions,	return &ContingencyTable{	}		total *= d	for _, d := range dimensions {	total := 1func NewContingencyTable(dimensions []int) *ContingencyTable {// NewContingencyTable creates a new contingency table}	Counts     []int64 // Flattened counts	Dimensions []int   // Size of each dimensiontype ContingencyTable struct {// Used by DDIA for post-processing LBc results// ContingencyTable represents a multi-dimensional contingency table}	return result	}		result *= base	for i := 0; i < int(exp); i++ {	result := 1.0func pow(base, exp float64) float64 {// Helper function for power}	}, nil		Config:            LBcConfig{Delta: pbmvBlocks[0].Delta},		NumCategories:     numCategories,		PackedCiphertexts: []*rlwe.Ciphertext{totalSum},	return &LBcResult{	// Note: BBMV doesn't directly store category count; caller must track this	numCategories := []int{pbmvBlocks[0].NumCategories}	// Collect category counts	}		}			}				return nil, fmt.Errorf("failed to add block %d: %w", blockIdx, err)			if err := c.eval.AddInPlace(totalSum, blockSum); err != nil {		} else {			totalSum = blockSum		if totalSum == nil {		}			return nil, fmt.Errorf("failed to sum slots in block %d: %w", blockIdx, err)		if err != nil {		blockSum, err := c.eval.SumSlots(block, c.slots)	for blockIdx, block := range resultBlocks {	var totalSum *rlwe.Ciphertext	// Sum across all blocks	}		resultBlocks[blockIdx] = result		}			}				return nil, fmt.Errorf("failed to multiply BBMV in block %d: %w", blockIdx, err)			if err != nil {			result, err = c.eval.Mul(result, bbmvSet[blockIdx].Ciphertext)			var err error		for _, bbmvSet := range bbmvBlockSets {		result := pbmvBlocks[blockIdx].Ciphertext.CopyNew()	for blockIdx := 0; blockIdx < numBlocks; blockIdx++ {	resultBlocks := make([]*rlwe.Ciphertext, numBlocks)	// Multiply PBMV by all BBMVs for each block	}		}			return nil, fmt.Errorf("BBMV set %d has %d blocks, expected %d", i, len(bbmvSet), numBlocks)		if len(bbmvSet) != numBlocks {	for i, bbmvSet := range bbmvBlockSets {	// Verify all BBMV sets have matching block counts	numBlocks := len(pbmvBlocks)	}		return nil, fmt.Errorf("no PBMV blocks provided")	if len(pbmvBlocks) == 0 {) (*LBcResult, error) {	bbmvBlockSets [][]*BBMVBlock, // One set per additional categorical variable	pbmvBlocks []*PBMVBlock,func (c *CategoricalOps) LargeBinCount(// Returns packed ciphertexts that DDIA will decrypt and post-process// LargeBinCount computes contingency table counts using PBMV/BBMV encoding}	Config            LBcConfig	NumCategories     []int // Categories per variable	PackedCiphertexts []*rlwe.Ciphertexttype LBcResult struct {// This is decrypted and post-processed by DDIA// LBcResult holds the result of a Large-Bin-Count operation}	return bbmvBlocks, nil	}		}			Lambda:     config.Lambda,			Ciphertext: ct,		bbmvBlocks[blockIdx] = &BBMVBlock{		}			return nil, fmt.Errorf("failed to encrypt BBMV block %d: %w", blockIdx, err)		if err != nil {		ct, err := encryptor.Encrypt(pt)		}			return nil, fmt.Errorf("failed to encode BBMV block %d: %w", blockIdx, err)		if err != nil {		pt, err := c.encoder.EncodeFloat64(values, level)		}			}				values[i] = scale			if blockValidity[i] > 0.5 && blockData[i] == targetCategory {		for i := 0; i < len(blockData) && i < c.slots; i++ {		values := make([]float64, c.slots)		blockValidity := validityData[blockIdx]		blockData := categoryData[blockIdx]	for blockIdx := 0; blockIdx < numBlocks; blockIdx++ {	scale := float64(int(1) << config.Lambda) // 2^Λ	bbmvBlocks := make([]*BBMVBlock, numBlocks)	numBlocks := len(categoryData)) ([]*BBMVBlock, error) {	level int,	encryptor *he.Encryptor,	config LBcConfig,	targetCategory int,	validityData [][]float64,	categoryData [][]int,func (c *CategoricalOps) GenerateBBMV(// Encodes category match as {0, 2^Λ}// GenerateBBMV creates a Big Bin Mask Vector for subsequent categorical variables}	return pbmvBlocks, nil	}		}			Delta:         config.Delta,			NumCategories: numCategories,			Ciphertext:    ct,		pbmvBlocks[blockIdx] = &PBMVBlock{		}			return nil, fmt.Errorf("failed to encrypt PBMV block %d: %w", blockIdx, err)		if err != nil {		ct, err := encryptor.Encrypt(pt)		}			return nil, fmt.Errorf("failed to encode PBMV block %d: %w", blockIdx, err)		if err != nil {		pt, err := c.encoder.EncodeFloat64(values, level)		}			}				}					values[i] = pow(delta, float64(cat-1))					// Position = Δ * (cat - 1), value = 2^position				if cat >= 1 && cat <= numCategories {				cat := blockData[i]			if blockValidity[i] > 0.5 {		for i := 0; i < len(blockData) && i < c.slots; i++ {		values := make([]float64, c.slots)		// Encode: for each slot, encode 2^(Δ * (category - 1)) if valid		blockValidity := validityData[blockIdx]		blockData := categoryData[blockIdx]	for blockIdx := 0; blockIdx < numBlocks; blockIdx++ {	delta := float64(int(1) << config.Delta) // 2^Δ	pbmvBlocks := make([]*PBMVBlock, numBlocks)	numBlocks := len(categoryData)) ([]*PBMVBlock, error) {	level int,	encryptor *he.Encryptor,	config LBcConfig,	numCategories int,	validityData [][]float64,	categoryData [][]int,func (c *CategoricalOps) GeneratePBMV(// Each row encodes its category value as a one-hot in bit-fields spaced by Delta// GeneratePBMV creates a Packed Bin Mask Vector for the first categorical variable}	Lambda     int	Ciphertext *rlwe.Ciphertexttype BBMVBlock struct {// Used for subsequent categorical variables in LBc// BBMVBlock represents a Big Bin Mask Vector block}	Delta      int	NumCategories int	Ciphertext *rlwe.Ciphertexttype PBMVBlock struct {// Used for the first categorical variable in LBc// PBMVBlock represents a Packed Bin Mask Vector block}	}		Lambda: 20, // 2^20 scale for BBMV		Delta:  8,  // 2^8 = 256 spacing	return LBcConfig{func DefaultLBcConfig() LBcConfig {// DefaultLBcConfig returns default LBc configuration}	Lambda int // Λ: bit separation for BBMV (log2 of the encoding scale)	Delta  int // Δ: spacing between category encodings in PBMVtype LBcConfig struct {// LBcConfig holds configuration for Large-Bin-Count operation}	return combinedMask, nil	}		combinedMask[blockIdx] = mask		}			}				return nil, fmt.Errorf("failed to multiply mask in block %d: %w", blockIdx, err)			if err != nil {			mask, err = c.eval.Mul(mask, bmv[blockIdx])			var err error			}				return nil, fmt.Errorf("BMV block %d not found for column %s value %d", blockIdx, cond.ColumnName, cond.Value)			if bmv == nil || blockIdx >= len(bmv) {			bmv := bmvSet[cond.Value]			}				return nil, fmt.Errorf("BMV set not found for column %s", cond.ColumnName)			if !ok {			bmvSet, ok := bmvSets[cond.ColumnName]		for _, cond := range conditions {		// Multiply by each condition's BMV		mask := validityBlocks[blockIdx].CopyNew()		// Start with validity	for blockIdx := 0; blockIdx < numBlocks; blockIdx++ {	combinedMask := make([]*rlwe.Ciphertext, numBlocks)	numBlocks := len(validityBlocks)) ([]*rlwe.Ciphertext, error) {	conditions []Condition,	bmvSets map[string]BMVSet,	validityBlocks []*rlwe.Ciphertext,func (c *CategoricalOps) buildCombinedMask(// buildCombinedMask creates a mask that is 1 only where all conditions are met}	return c.numericOps.Variance(targetBlocks, combinedMask)	// Use NumericOps.Variance with the combined mask	}		return nil, fmt.Errorf("failed to build combined mask: %w", err)	if err != nil {	combinedMask, err := c.buildCombinedMask(validityBlocks, bmvSets, conditions)	// Build combined mask) (*rlwe.Ciphertext, error) {	conditions []Condition,	bmvSets map[string]BMVSet,	validityBlocks []*rlwe.Ciphertext,	targetBlocks []*rlwe.Ciphertext,func (c *CategoricalOps) BinVariance(// BinVariance (Bv) computes the variance of a numeric column for rows matching conditions}	return c.numericOps.Mean(targetBlocks, combinedMask)	// Use NumericOps.Mean with the combined mask as validity	}		return nil, fmt.Errorf("failed to build combined mask: %w", err)	if err != nil {	combinedMask, err := c.buildCombinedMask(validityBlocks, bmvSets, conditions)	// Build combined mask: validity * all BMV conditions) (*rlwe.Ciphertext, error) {	conditions []Condition,	bmvSets map[string]BMVSet,	validityBlocks []*rlwe.Ciphertext,	targetBlocks []*rlwe.Ciphertext,func (c *CategoricalOps) BinAverage(// targetBlocks: encrypted blocks of the numeric target column// BinAverage (Ba) computes the average of a numeric column for rows matching conditions}	return c.numericOps.CountSum(maskBlocks)	// Count: sum of mask values	}		maskBlocks[blockIdx] = mask		}			}				}					return nil, fmt.Errorf("failed to multiply BMV masks in block %d: %w", blockIdx, err)				if err != nil {				mask, err = c.eval.Mul(mask, bmv[blockIdx])				var err error			} else {				mask = bmv[blockIdx].CopyNew()			if mask == nil {			}				return nil, fmt.Errorf("BMV block %d not found for column %s value %d", blockIdx, cond.ColumnName, cond.Value)			if bmv == nil || blockIdx >= len(bmv) {			bmv := bmvSet[cond.Value]			}				return nil, fmt.Errorf("BMV set not found for column %s", cond.ColumnName)			if !ok {			bmvSet, ok := bmvSets[cond.ColumnName]		for _, cond := range conditions {		var mask *rlwe.Ciphertext		// Start with all 1s (or first condition's BMV)	for blockIdx := 0; blockIdx < numBlocks; blockIdx++ {	maskBlocks := make([]*rlwe.Ciphertext, numBlocks)	// Build mask for each block by multiplying BMVs for all conditions	numBlocks := len(validityBlocks)	}		return c.numericOps.CountSum(validityBlocks)		// No conditions: just count valid rows	if len(conditions) == 0 {) (*rlwe.Ciphertext, error) {	conditions []Condition,	bmvSets map[string]BMVSet, // columnName -> BMVSet	validityBlocks []*rlwe.Ciphertext,func (c *CategoricalOps) BinCount(// Returns a ciphertext where all slots contain the count// BinCount (Bc) computes the count of rows matching all conditions}	Value      int	ColumnName stringtype Condition struct {// Condition represents a categorical filter condition (column = value)}	return bmvSet, nil	}		}			bmvSet[cat][blockIdx] = ct			}				return nil, fmt.Errorf("failed to encrypt BMV for category %d block %d: %w", cat, blockIdx, err)			if err != nil {			ct, err := encryptor.Encrypt(pt)			}				return nil, fmt.Errorf("failed to encode BMV for category %d block %d: %w", cat, blockIdx, err)			if err != nil {			pt, err := c.encoder.EncodeFloat64(maskValues, level)			// Encode and encrypt			}				}					maskValues[i] = 0.0				} else {					maskValues[i] = 1.0				if blockValidity[i] > 0.5 && blockData[i] == cat {			for i := 0; i < len(blockData) && i < c.slots; i++ {			maskValues := make([]float64, c.slots)		for cat := 1; cat <= numCategories; cat++ {		// For each category, create the mask vector		blockValidity := validityData[blockIdx]		blockData := categoryData[blockIdx]	for blockIdx := 0; blockIdx < numBlocks; blockIdx++ {	// Process each block	}		bmvSet[cat] = make([]*rlwe.Ciphertext, numBlocks)	for cat := 1; cat <= numCategories; cat++ {	// Initialize slices for each category	bmvSet := make(BMVSet)	}		return nil, fmt.Errorf("no data blocks provided")	if numBlocks == 0 {	numBlocks := len(categoryData)) (BMVSet, error) {	level int,	encryptor *he.Encryptor,	numCategories int,	validityData [][]float64,	categoryData [][]int,func (c *CategoricalOps) GenerateBMV(// validityData: for each block, a slice of validity flags (0 or 1)// categoryData: for each block, a slice of category values (1-indexed)// GenerateBMV creates BMV ciphertexts from plaintext categorical datatype BMVSet map[int][]*rlwe.Ciphertext// bmv[categoryValue][blockIndex] -> ciphertext with 1 where row has that category// BMVSet represents a set of Bin Mask Vectors for a categorical variable}	}		slots:      slots,		numericOps: numeric.NewNumericOps(eval, encoder, slots),		encoder:    encoder,		eval:       eval,	return &CategoricalOps{func NewCategoricalOps(eval *he.Evaluator, encoder *he.Encoder, slots int) *CategoricalOps {// NewCategoricalOps creates a new CategoricalOps instance}	slots      int	numericOps *numeric.NumericOps	encoder    *he.Encoder	eval       *he.Evaluatortype CategoricalOps struct {// CategoricalOps provides categorical statistical operations on encrypted data)	"github.com/hkanpak21/lattigostats/pkg/ops/numeric"	"github.com/hkanpak21/lattigostats/pkg/he"	"github.com/tuneinsight/lattigo/v6/core/rlwe"