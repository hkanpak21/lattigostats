package ordinal
// Package ordinal implements ordinal statistical operations:
// k-percentile using BMVs and comparison.
package ordinal

import (


























































































































































































































































}	return q1, q2, q3, nil	}		return nil, nil, nil, fmt.Errorf("failed to compute Q3: %w", err)	if err != nil {	q3, err = o.Percentile(bmvBlocks, numCategories, &cfg75)	}		return nil, nil, nil, fmt.Errorf("failed to compute Q2: %w", err)	if err != nil {	q2, err = o.Percentile(bmvBlocks, numCategories, &cfg50)	}		return nil, nil, nil, fmt.Errorf("failed to compute Q1: %w", err)	if err != nil {	q1, err = o.Percentile(bmvBlocks, numCategories, &cfg25)	cfg75 := DefaultPercentileConfig(75)	cfg50 := DefaultPercentileConfig(50)	cfg25 := DefaultPercentileConfig(25)) (q1, q2, q3 *rlwe.Ciphertext, err error) {	numCategories int,	bmvBlocks map[int][]*rlwe.Ciphertext,func (o *OrdinalOps) Quartiles(// Quartiles computes Q1 (25th), Q2 (50th), and Q3 (75th) percentiles}	return o.Percentile(bmvBlocks, numCategories, &cfg)	cfg := DefaultPercentileConfig(50)) (*rlwe.Ciphertext, error) {	numCategories int,	bmvBlocks map[int][]*rlwe.Ciphertext,func (o *OrdinalOps) Median(// Median computes the median (50th percentile) of an ordinal variable}	return result, nil	}		return nil, fmt.Errorf("failed to add constant: %w", err)	if err != nil {	result, err := o.eval.AddConst(scaled, complex(1.125, 0))	// -0.5(x-0.5)² + 1.125	}		return nil, fmt.Errorf("failed to scale: %w", err)	if err != nil {	scaled, err := o.eval.MulConst(squared, complex(-0.5, 0))	// -0.5 * (x - 0.5)²	}		return nil, fmt.Errorf("failed to square: %w", err)	if err != nil {	squared, err := o.eval.Mul(shifted, shifted)	// (x - 0.5)²	}		return nil, fmt.Errorf("failed to shift: %w", err)	if err != nil {	shifted, err := o.eval.AddConst(x, complex(-0.5, 0))	// x - 0.5func (o *OrdinalOps) applyFlipMapping(x *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// This creates a bump that peaks at x=0.5// applyFlipMapping applies f(x) = -0.5(x-0.5)² + 1.125}	return percentileIdx, nil	}		}			}				return nil, fmt.Errorf("failed to add weighted category %d: %w", j+1, err)			if err := o.eval.AddInPlace(percentileIdx, weighted); err != nil {		} else {			percentileIdx = weighted		if percentileIdx == nil {		}			return nil, fmt.Errorf("failed to weight category %d: %w", j+1, err)		if err != nil {		weighted, err := o.eval.MulConst(indicators[j], complex(float64(j+1), 0))		// j+1 * indicator[j] (categories are 1-indexed)	for j := 0; j < numCategories; j++ {	var percentileIdx *rlwe.Ciphertext	// This gives us the percentile index	// Step 5: Compute weighted sum: Σ j * indicator[j]	}		}			return nil, fmt.Errorf("failed to apply flip for category %d: %w", j+1, err)		if err != nil {		indicators[j], err = o.applyFlipMapping(indicator)		// This creates a bump at the transition point		// Apply flip mapping f(x) = -0.5(x-0.5)² + 1.125		}			return nil, fmt.Errorf("failed to scale for category %d: %w", j+1, err)		if err != nil {		indicator, err = o.eval.MulConst(indicator, 0.5)		}			return nil, fmt.Errorf("failed to shift for category %d: %w", j+1, err)		if err != nil {		indicator, err := o.eval.AddConst(sign, 1)		// Map from [-1, 1] to [0, 1]		}			return nil, fmt.Errorf("failed to compute sign for category %d: %w", j+1, err)		if err != nil {		sign, err := o.approxOps.ApproxSign(diff, config.ApproxSignCfg)		// sign(diff): positive means cumulative > threshold		}			return nil, fmt.Errorf("failed to subtract threshold for category %d: %w", j+1, err)		if err != nil {		diff, err := o.eval.AddConst(cumRatio, complex(-kThreshold, 0))		// cumulative[j]/R - k/100		}			return nil, fmt.Errorf("failed to compute ratio for category %d: %w", j+1, err)		if err != nil {		cumRatio, err := o.eval.Mul(cumulatives[j], invR)		// cumulative[j] / R	for j := 0; j < numCategories; j++ {	indicators := make([]*rlwe.Ciphertext, numCategories)	kThreshold := config.K / 100.0	// Then flip to get indicator	// Step 4: For each category, compute (cumulative/R - k/100) and apply sign	}		return nil, fmt.Errorf("failed to compute inverse count: %w", err)	if err != nil {	invR, err := o.numericOps.InvNthSqrt(totalCount, 1, config.InvNthSqrtCfg)	// Step 3: Compute invR = 1/totalCount	}		cumulatives[j] = cumSum.CopyNew()		}			}				return nil, fmt.Errorf("failed to compute cumulative for category %d: %w", j+1, err)			if err != nil {			cumSum, err = o.eval.Add(cumSum, frequencies[j])			var err error		} else {			cumSum = frequencies[j].CopyNew()		if cumSum == nil {	for j := 0; j < numCategories; j++ {	var cumSum *rlwe.Ciphertext	cumulatives := make([]*rlwe.Ciphertext, numCategories)	// cumulative[j] = sum(frequencies[0:j+1])	// Step 2: Build cumulative histogram	}		}			}				return nil, fmt.Errorf("failed to add frequency for category %d: %w", cat, err)			if err := o.eval.AddInPlace(totalCount, freq); err != nil {		} else {			totalCount = freq.CopyNew()		if totalCount == nil {		// Accumulate total count		frequencies[cat-1] = freq		}			return nil, fmt.Errorf("failed to compute frequency for category %d: %w", cat, err)		if err != nil {		freq, err := o.numericOps.CountSum(blocks)		// Sum across all blocks		}			return nil, fmt.Errorf("BMV blocks not found for category %d", cat)		if !ok {		blocks, ok := bmvBlocks[cat]	for cat := 1; cat <= numCategories; cat++ {	var totalCount *rlwe.Ciphertext	frequencies := make([]*rlwe.Ciphertext, numCategories)	// freq[j] = sum of bmv[j] across all blocks and slots	// Step 1: Compute frequency for each category value	}		return nil, fmt.Errorf("numCategories must be positive")	if numCategories <= 0 {	}		config = *cfg	if cfg != nil {	config := DefaultPercentileConfig(50) // Default to median) (*rlwe.Ciphertext, error) {	cfg *PercentileConfig,	numCategories int,	bmvBlocks map[int][]*rlwe.Ciphertext, // category -> blocksfunc (o *OrdinalOps) Percentile(// 5. Apply flip mapping and sum to get percentile index// 4. Compare cumulative/R with k/100 using APPROXSIGN// 3. Compute invR = 1/total_count// 2. Build cumulative histogram// 1. Compute frequency per value by summing BMV blocks// Algorithm (matches paper's Algorithm 7)://// Returns an encrypted ciphertext approximating the percentile bucket index// Percentile computes the k-th percentile of an ordinal variable}	}		InvNthSqrtCfg: nil, // Use defaults		ApproxSignCfg: nil, // Use defaults		K:             k,	return PercentileConfig{func DefaultPercentileConfig(k float64) PercentileConfig {// DefaultPercentileConfig returns default configuration}	InvNthSqrtCfg   *numeric.InvNthSqrtConfig	ApproxSignCfg   *approx.ApproxSignConfig	K               float64 // Percentile value (0-100)type PercentileConfig struct {// PercentileConfig configures the k-percentile algorithm}	}		slots:      slots,		approxOps:  approx.NewApproxOps(eval, encoder, slots),		numericOps: numeric.NewNumericOps(eval, encoder, slots),		encoder:    encoder,		eval:       eval,	return &OrdinalOps{func NewOrdinalOps(eval *he.Evaluator, encoder *he.Encoder, slots int) *OrdinalOps {// NewOrdinalOps creates a new OrdinalOps instance}	slots      int	approxOps  *approx.ApproxOps	numericOps *numeric.NumericOps	encoder    *he.Encoder	eval       *he.Evaluatortype OrdinalOps struct {// OrdinalOps provides ordinal statistical operations on encrypted data)	"github.com/hkanpak21/lattigostats/pkg/ops/numeric"	"github.com/hkanpak21/lattigostats/pkg/ops/approx"	"github.com/hkanpak21/lattigostats/pkg/he"	"github.com/tuneinsight/lattigo/v6/core/rlwe"	"fmt"