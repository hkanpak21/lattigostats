package he
// Package he provides a thin wrapper around Lattigo's CKKS evaluator, encoder,
// and bootstrapper with level tracking and profiling support.
package he

import (












































































































































































































































































































































































































































































































}	return d.dec.DecryptNew(ct)func (d *Decryptor) Decrypt(ct *rlwe.Ciphertext) *rlwe.Plaintext {// Decrypt decrypts a ciphertext}	}		dec:    rlwe.NewDecryptor(params, sk),		params: params,	return &Decryptor{func NewDecryptor(params ckks.Parameters, sk *rlwe.SecretKey) *Decryptor {// NewDecryptor creates a new decryptor with the secret key}	dec    *rlwe.Decryptor	params ckks.Parameterstype Decryptor struct {// Decryptor handles decryption operations (DDIA only!)}	return ct, nil	}		return nil, fmt.Errorf("Encrypt failed: %w", err)	if err != nil {	ct, err := e.enc.EncryptNew(pt)func (e *Encryptor) Encrypt(pt *rlwe.Plaintext) (*rlwe.Ciphertext, error) {// Encrypt encrypts a plaintext}	}		enc:    rlwe.NewEncryptor(params, pk),		params: params,	return &Encryptor{func NewEncryptor(params ckks.Parameters, pk *rlwe.PublicKey) *Encryptor {// NewEncryptor creates a new encryptor with the public key}	enc    *rlwe.Encryptor	params ckks.Parameterstype Encryptor struct {// Encryptor handles encryption operations}	return rlwe.NewMemEvaluationKeySet(rlk, galKeyList...)	copy(galKeyList, galKeys)	galKeyList := make([]*rlwe.GaloisKey, len(galKeys))	// Convert to the correct type	galKeys := kg.GenGaloisKeys(rotationSteps)	rlk := kg.GenRelinKey()func (kg *KeyGenerator) GenEvaluationKeySet(rotationSteps []int) *rlwe.MemEvaluationKeySet {// GenEvaluationKeySet generates a complete evaluation key set}	return kg.kgen.GenGaloisKeysNew(galEls, kg.sk)	}		galEls[i] = kg.params.GaloisElement(step)	for i, step := range steps {	galEls := make([]uint64, len(steps))func (kg *KeyGenerator) GenGaloisKeys(steps []int) []*rlwe.GaloisKey {// GenGaloisKeys generates Galois keys for the given rotation steps}	return kg.kgen.GenRelinearizationKeyNew(kg.sk)func (kg *KeyGenerator) GenRelinKey() *rlwe.RelinearizationKey {// GenRelinKey generates relinearization key}	return kg.pkfunc (kg *KeyGenerator) PublicKey() *rlwe.PublicKey {// PublicKey returns the public key}	return kg.skfunc (kg *KeyGenerator) SecretKey() *rlwe.SecretKey {// SecretKey returns the secret key (DDIA only!)}	}		pk:     pk,		sk:     sk,		kgen:   kgen,		params: params,	return &KeyGenerator{	sk, pk := kgen.GenKeyPairNew()	kgen := rlwe.NewKeyGenerator(params)func NewKeyGenerator(params ckks.Parameters) *KeyGenerator {// NewKeyGenerator creates a new key generator}	pk     *rlwe.PublicKey	sk     *rlwe.SecretKey	kgen   *rlwe.KeyGenerator	params ckks.Parameterstype KeyGenerator struct {// KeyGenerator handles key generation for DDIA}	return e.params.MaxSlots()func (e *Encoder) Slots() int {// Slots returns the number of slots}	return values, nil	}		values[i] = real(v)	for i, v := range complex128Values {	values := make([]float64, len(complex128Values))	}		return nil, err	if err != nil {	complex128Values, err := e.Decode(pt)func (e *Encoder) DecodeFloat64(pt *rlwe.Plaintext) ([]float64, error) {// DecodeFloat64 decodes a plaintext into real-valued floats}	return values, nil	}		return nil, fmt.Errorf("Decode failed: %w", err)	if err := e.encoder.Decode(pt, values); err != nil {	values := make([]complex128, e.params.MaxSlots())func (e *Encoder) Decode(pt *rlwe.Plaintext) ([]complex128, error) {// Decode decodes a plaintext into a slice of complex values}	return e.Encode(complex128Values, level)	}		complex128Values[i] = complex(v, 0)	for i, v := range values {	complex128Values := make([]complex128, len(values))func (e *Encoder) EncodeFloat64(values []float64, level int) (*rlwe.Plaintext, error) {// EncodeFloat64 encodes a slice of float64 values}	return pt, nil	}		return nil, fmt.Errorf("Encode failed: %w", err)	if err := e.encoder.Encode(values, pt); err != nil {	pt := ckks.NewPlaintext(e.params, level)func (e *Encoder) Encode(values []complex128, level int) (*rlwe.Plaintext, error) {// Encode encodes a slice of complex values into a plaintext at the given level}	}		encoder: ckks.NewEncoder(params),		params:  params,	return &Encoder{func NewEncoder(params ckks.Parameters) *Encoder {// NewEncoder creates a new Encoder wrapper}	encoder *ckks.Encoder	params  ckks.Parameterstype Encoder struct {// Encoder wraps Lattigo's CKKS encoder}	return e.bootstrapper != nilfunc (e *Evaluator) HasBootstrapper() bool {// HasBootstrapper returns true if bootstrapping is available}	return ct, nil	}		return e.Bootstrap(ct)	if ct.Level() < minLevel && e.bootstrapper != nil {func (e *Evaluator) BootstrapIfNeeded(ct *rlwe.Ciphertext, minLevel int) (*rlwe.Ciphertext, error) {// BootstrapIfNeeded bootstraps if the ciphertext level is below the threshold}	return e.bootstrapper.Bootstrap(ct)	}()		e.stats.mu.Unlock()		e.stats.BootstrapTime += time.Since(start)		e.stats.BootstrapCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()	}		return nil, fmt.Errorf("bootstrapper not configured")	if e.bootstrapper == nil {func (e *Evaluator) Bootstrap(ct *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Bootstrap refreshes a ciphertext to increase its level}	return result, nil	}		}			return nil, fmt.Errorf("SumSlots addition failed: %w", err)		if err := e.AddInPlace(result, rotated); err != nil {		}			return nil, fmt.Errorf("SumSlots rotation failed: %w", err)		if err != nil {		rotated, err := e.Rotate(result, step)	for step := 1; step < slots; step *= 2 {	result := ct.CopyNew()func (e *Evaluator) SumSlots(ct *rlwe.Ciphertext, slots int) (*rlwe.Ciphertext, error) {// Returns a ciphertext where all slots contain the sum// SumSlots performs a full reduction sum across all slots using rotations}	return e.eval.Rotate(ct, k, ct)	}()		e.stats.mu.Unlock()		e.stats.RotTime += time.Since(start)		e.stats.RotCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) RotateInPlace(ct *rlwe.Ciphertext, k int) error {// RotateInPlace performs a slot rotation in place}	return result, nil	}		return nil, fmt.Errorf("Rotate failed: %w", err)	if err != nil {	result, err := e.eval.RotateNew(ct, k)	}()		e.stats.mu.Unlock()		e.stats.RotTime += time.Since(start)		e.stats.RotCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) Rotate(ct *rlwe.Ciphertext, k int) (*rlwe.Ciphertext, error) {// Rotate performs a slot rotation by the given amount}	return result, nil	}		return nil, fmt.Errorf("AddConst failed: %w", err)	if err != nil {	result, err := e.eval.AddNew(ct, constant)	}()		e.stats.mu.Unlock()		e.stats.AddTime += time.Since(start)		e.stats.AddCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) AddConst(ct *rlwe.Ciphertext, constant complex128) (*rlwe.Ciphertext, error) {// AddConst performs ct + constant}	return result, nil	e.stats.mu.Unlock()	e.stats.RescaleCount++	e.stats.mu.Lock()	}		return nil, fmt.Errorf("Rescale failed: %w", err)	if err := e.eval.Rescale(result, result); err != nil {	// Rescale	}		return nil, fmt.Errorf("MulConst failed: %w", err)	if err != nil {	result, err := e.eval.MulNew(ct, constant)	}()		e.stats.mu.Unlock()		e.stats.MulTime += time.Since(start)		e.stats.MulCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) MulConst(ct *rlwe.Ciphertext, constant complex128) (*rlwe.Ciphertext, error) {// MulConst performs ct * constant}	return result, nil	e.stats.mu.Unlock()	e.stats.RescaleCount++	e.stats.mu.Lock()	}		return nil, fmt.Errorf("Rescale failed: %w", err)	if err := e.eval.Rescale(result, result); err != nil {	// Rescale	}		return nil, fmt.Errorf("MulPlain failed: %w", err)	if err != nil {	result, err := e.eval.MulNew(ct, pt)	}()		e.stats.mu.Unlock()		e.stats.MulTime += time.Since(start)		e.stats.MulCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) MulPlain(ct *rlwe.Ciphertext, pt *rlwe.Plaintext) (*rlwe.Ciphertext, error) {// MulPlain performs ct * plaintext}	return result, nil	e.stats.mu.Unlock()	e.stats.RescaleCount++	e.stats.mu.Lock()	}		return nil, fmt.Errorf("Rescale failed: %w", err)	if err := e.eval.Rescale(result, result); err != nil {	// Rescale to maintain scale	e.stats.mu.Unlock()	e.stats.MulTime += time.Since(start)	e.stats.RelinCount++	e.stats.MulCount++	e.stats.mu.Lock()	}		return nil, fmt.Errorf("MulRelin failed: %w", err)	if err != nil {	result, err := e.eval.MulRelinNew(ct1, ct2)	start := time.Now()func (e *Evaluator) Mul(ct1, ct2 *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Mul performs ct1 * ct2 with relinearization and rescaling}	return result, nil	}		return nil, fmt.Errorf("Sub failed: %w", err)	if err != nil {	result, err := e.eval.SubNew(ct1, ct2)	}()		e.stats.mu.Unlock()		e.stats.AddTime += time.Since(start)		e.stats.AddCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) Sub(ct1, ct2 *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Sub performs ct1 - ct2}	return e.eval.Add(ct1, ct2, ct1)	}()		e.stats.mu.Unlock()		e.stats.AddTime += time.Since(start)		e.stats.AddCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) AddInPlace(ct1, ct2 *rlwe.Ciphertext) error {// AddInPlace performs ct1 += ct2}	return result, nil	}		return nil, fmt.Errorf("Add failed: %w", err)	if err != nil {	result, err := e.eval.AddNew(ct1, ct2)	}()		e.stats.mu.Unlock()		e.stats.AddTime += time.Since(start)		e.stats.AddCount++		e.stats.mu.Lock()	defer func() {	start := time.Now()func (e *Evaluator) Add(ct1, ct2 *rlwe.Ciphertext) (*rlwe.Ciphertext, error) {// Add performs ct1 + ct2}	return ct.Level()func (e *Evaluator) Level(ct *rlwe.Ciphertext) int {// Level returns the current level of a ciphertext}	return e.paramsfunc (e *Evaluator) Params() ckks.Parameters {// Params returns the CKKS parameters}	return e.statsfunc (e *Evaluator) GetStats() *Stats {// GetStats returns the current statistics}	}		bootstrapper: cfg.Bootstrapper,		stats:        &Stats{},		eval:         ckks.NewEvaluator(cfg.Params, cfg.EvalKey),		params:       cfg.Params,	return &Evaluator{func NewEvaluator(cfg EvaluatorConfig) *Evaluator {// NewEvaluator creates a new Evaluator wrapper}	Bootstrapper Bootstrapper	EvalKey      *rlwe.MemEvaluationKeySet	Params       ckks.Parameterstype EvaluatorConfig struct {// EvaluatorConfig holds configuration for creating an Evaluator}	OutputLevel() int	MinimumInputLevel() int	Bootstrap(ct *rlwe.Ciphertext) (*rlwe.Ciphertext, error)type Bootstrapper interface {// Bootstrapper interface for bootstrapping operations}	bootstrapper Bootstrapper	// Optional bootstrapper (nil if not enabled)	stats  *Stats	eval   *ckks.Evaluator	params ckks.Parameterstype Evaluator struct {// Evaluator wraps Lattigo's CKKS evaluator with additional functionality}	)		s.BootstrapCount, s.BootstrapTime.Seconds(),		s.RelinCount, s.RelinTime.Seconds(),		s.RescaleCount, s.RescaleTime.Seconds(),		s.RotCount, s.RotTime.Seconds(),		s.AddCount, s.AddTime.Seconds(),		s.MulCount, s.MulTime.Seconds(),		"HE Stats: Mul=%d (%.2fs), Add=%d (%.2fs), Rot=%d (%.2fs), Rescale=%d (%.2fs), Relin=%d (%.2fs), Bootstrap=%d (%.2fs)",	return fmt.Sprintf(	defer s.mu.Unlock()	s.mu.Lock()func (s *Stats) String() string {// String returns a human-readable summary}	s.BootstrapTime = 0	s.RelinTime = 0	s.RescaleTime = 0	s.RotTime = 0	s.AddTime = 0	s.MulTime = 0	s.BootstrapCount = 0	s.RelinCount = 0	s.RescaleCount = 0	s.RotCount = 0	s.AddCount = 0	s.MulCount = 0	defer s.mu.Unlock()	s.mu.Lock()func (s *Stats) Reset() {// Reset clears all statistics}	BootstrapTime time.Duration	RelinTime     time.Duration	RescaleTime   time.Duration	RotTime       time.Duration	AddTime       time.Duration	MulTime       time.Duration	BootstrapCount int64	RelinCount     int64	RescaleCount   int64	RotCount       int64	AddCount       int64	MulCount       int64	mu sync.Mutextype Stats struct {// Stats tracks HE operation statistics for profiling)	"github.com/tuneinsight/lattigo/v6/schemes/ckks"	"github.com/tuneinsight/lattigo/v6/core/rlwe"	"time"	"sync"	"fmt"