package storage
// Package storage provides ciphertext serialization, chunked storage,
// and streaming read/write for encrypted tables.
package storage

import (
	"encoding/binary"






















































































































































































































































}	return nilfunc (ts *TableStorage) Close() error {// Close cleans up any resources (currently a no-op, but provided for future use)}	return err == nil	_, err := os.Stat(path)	path := ts.bmvFilePath(columnName, categoryValue, blockIndex)func (ts *TableStorage) BMVExists(columnName string, categoryValue, blockIndex int) bool {// BMVExists checks if a BMV file exists}	return err == nil	_, err := os.Stat(path)	path := ts.blockFilePath(columnName, blockIndex)func (ts *TableStorage) BlockExists(columnName string, blockIndex int) bool {// BlockExists checks if a block file exists}	bi.current = 0func (bi *BlockIterator) Reset() {// Reset resets the iterator to the beginning}	return ct, nil	bi.current++	}		return nil, err	if err != nil {	ct, err := bi.storage.ReadBlock(bi.columnName, bi.current)	}		return nil, io.EOF	if !bi.HasNext() {func (bi *BlockIterator) Next() (*rlwe.Ciphertext, error) {// Next reads and returns the next block}	return bi.current < bi.totalfunc (bi *BlockIterator) HasNext() bool {// HasNext returns true if there are more blocks to read}	}		total:      ts.Metadata.BlockCount,		current:    0,		columnName: columnName,		storage:    ts,	return &BlockIterator{func (ts *TableStorage) NewBlockIterator(columnName string) *BlockIterator {// NewBlockIterator creates an iterator over column blocks}	total      int	current    int	columnName string	storage    *TableStoragetype BlockIterator struct {// BlockIterator provides streaming access to blocks}	return ts.ReadCiphertext(path)	path := ts.bmvFilePath(columnName, categoryValue, blockIndex)func (ts *TableStorage) ReadBMV(columnName string, categoryValue, blockIndex int) (*rlwe.Ciphertext, error) {// ReadBMV reads a bin mask vector block}	return ts.WriteCiphertext(path, ct)	path := ts.bmvFilePath(columnName, categoryValue, blockIndex)func (ts *TableStorage) WriteBMV(columnName string, categoryValue, blockIndex int, ct *rlwe.Ciphertext) error {// WriteBMV writes a bin mask vector block}	return ts.ReadCiphertext(path)	path := ts.validityFilePath(columnName, blockIndex)func (ts *TableStorage) ReadValidity(columnName string, blockIndex int) (*rlwe.Ciphertext, error) {// ReadValidity reads a validity vector block}	return ts.WriteCiphertext(path, ct)	path := ts.validityFilePath(columnName, blockIndex)func (ts *TableStorage) WriteValidity(columnName string, blockIndex int, ct *rlwe.Ciphertext) error {// WriteValidity writes a validity vector block}	return ts.ReadCiphertext(path)	path := ts.blockFilePath(columnName, blockIndex)func (ts *TableStorage) ReadBlock(columnName string, blockIndex int) (*rlwe.Ciphertext, error) {// ReadBlock reads a column block ciphertext}	return ts.WriteCiphertext(path, ct)	path := ts.blockFilePath(columnName, blockIndex)func (ts *TableStorage) WriteBlock(columnName string, blockIndex int, ct *rlwe.Ciphertext) error {// WriteBlock writes a column block ciphertext}	return ct, nil	}		return nil, fmt.Errorf("failed to unmarshal ciphertext: %w", err)	if err := ct.UnmarshalBinary(data); err != nil {	ct := rlwe.NewCiphertext(ts.params, 1, ts.params.MaxLevel())	// Unmarshal ciphertext	}		return nil, fmt.Errorf("failed to read data: %w", err)	if _, err := io.ReadFull(f, data); err != nil {	data := make([]byte, dataLen)	// Read ciphertext data	dataLen := binary.LittleEndian.Uint64(lenBuf)	}		return nil, fmt.Errorf("failed to read length: %w", err)	if _, err := io.ReadFull(f, lenBuf); err != nil {	lenBuf := make([]byte, 8)	// Read length prefix	defer f.Close()	}		return nil, fmt.Errorf("failed to open file: %w", err)	if err != nil {	f, err := os.Open(path)func (ts *TableStorage) ReadCiphertext(path string) (*rlwe.Ciphertext, error) {// ReadCiphertext reads a ciphertext from a file}	return nil	}		return fmt.Errorf("failed to write data: %w", err)	if _, err := f.Write(data); err != nil {	}		return fmt.Errorf("failed to write length: %w", err)	if _, err := f.Write(lenBuf); err != nil {	binary.LittleEndian.PutUint64(lenBuf, uint64(len(data)))	lenBuf := make([]byte, 8)	// Write length prefix for easier streaming reads	}		return fmt.Errorf("failed to marshal ciphertext: %w", err)	if err != nil {	data, err := ct.MarshalBinary()	// Write ciphertext using Lattigo's binary marshaling	defer f.Close()	}		return fmt.Errorf("failed to create file: %w", err)	if err != nil {	f, err := os.Create(path)func (ts *TableStorage) WriteCiphertext(path string, ct *rlwe.Ciphertext) error {// WriteCiphertext writes a ciphertext to a file}	return filepath.Join(ts.BasePath, BMVsDir, fmt.Sprintf("%s_v%d_%04d.bin", columnName, categoryValue, blockIndex))func (ts *TableStorage) bmvFilePath(columnName string, categoryValue, blockIndex int) string {// bmvFilePath returns the file path for a BMV block}	return filepath.Join(ts.BasePath, ValidityDir, fmt.Sprintf("%s_%04d.bin", columnName, blockIndex))func (ts *TableStorage) validityFilePath(columnName string, blockIndex int) string {// validityFilePath returns the file path for a validity block}	return filepath.Join(ts.BasePath, BlocksDir, fmt.Sprintf("%s_%04d.bin", columnName, blockIndex))func (ts *TableStorage) blockFilePath(columnName string, blockIndex int) string {// blockFilePath returns the file path for a column block}	}, nil		params:   params,		Metadata: metadata,		BasePath: basePath,	return &TableStorage{	}		return nil, fmt.Errorf("failed to load metadata: %w", err)	if err != nil {	metadata, err := schema.LoadMetadataFromFile(metaPath)	metaPath := filepath.Join(basePath, MetadataFile)func OpenTableStorage(basePath string, params ckks.Parameters) (*TableStorage, error) {// OpenTableStorage opens an existing table storage}	return ts, nil	}		return nil, fmt.Errorf("failed to save metadata: %w", err)	if err := metadata.SaveToFile(metaPath); err != nil {	metaPath := filepath.Join(basePath, MetadataFile)	// Save metadata	}		}			return nil, fmt.Errorf("failed to create directory %s: %w", dir, err)		if err := os.MkdirAll(dir, 0755); err != nil {	for _, dir := range dirs {	}		filepath.Join(basePath, BMVsDir),		filepath.Join(basePath, ValidityDir),		filepath.Join(basePath, BlocksDir),		basePath,	dirs := []string{	// Create directory structure	}		params:   params,		Metadata: metadata,		BasePath: basePath,	ts := &TableStorage{	}		return nil, fmt.Errorf("invalid metadata: %w", err)	if err := metadata.Validate(); err != nil {func NewTableStorage(basePath string, metadata *schema.TableMetadata, params ckks.Parameters) (*TableStorage, error) {// NewTableStorage creates a new table storage at the given path}	params   ckks.Parameters	Metadata *schema.TableMetadata	BasePath stringtype TableStorage struct {// TableStorage manages the on-disk storage of an encrypted table)	MetadataFile = "metadata.json"	BBMVDir     = "bbmv"	PBMVDir     = "pbmv"	BMVsDir     = "bmvs"	ValidityDir = "validity"	BlocksDir   = "blocks"	// Directory names within a table storage directoryconst ()	"github.com/hkanpak21/lattigostats/pkg/schema"	"github.com/tuneinsight/lattigo/v6/schemes/ckks"	"github.com/tuneinsight/lattigo/v6/core/rlwe"	"path/filepath"	"os"	"io"	"fmt"