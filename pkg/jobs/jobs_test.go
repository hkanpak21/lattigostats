package jobs
package jobs

import (
	"bytes"
	"testing"
)

func TestJobSpecValidation(t *testing.T) {
	tests := []struct {
		name    string
		spec    JobSpec
		wantErr bool
	}{
		{
			name: "valid mean",











































































































































































}	}		t.Error("Expected error for invalid spec")	if err == nil {	_, err = ParseJobSpec(bytes.NewReader([]byte(jsonData)))	jsonData := `{"id": "job", "operation": "mean"}`	// Valid JSON but invalid spec	}		t.Error("Expected error for invalid JSON")	if err == nil {	_, err := ParseJobSpec(bytes.NewReader([]byte("not json")))	// Invalid JSONfunc TestParseJobSpecInvalid(t *testing.T) {}	}		t.Errorf("Unexpected columns: %v", spec.Columns)	if len(spec.Columns) != 1 || spec.Columns[0] != "income" {	}		t.Errorf("Expected operation 'mean', got '%s'", spec.Operation)	if spec.Operation != OpMean {	}		t.Errorf("Expected ID 'test-job', got '%s'", spec.ID)	if spec.ID != "test-job" {	}		t.Fatalf("Failed to parse job spec: %v", err)	if err != nil {	spec, err := ParseJobSpec(bytes.NewReader([]byte(jsonData)))	}`		"description": "Compute mean income"		"columns": ["income"],		"operation": "mean",		"id": "test-job",	jsonData := `{func TestParseJobSpec(t *testing.T) {}	}		})			}				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {			err := tt.spec.Validate()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: true,			},				Operation: "unknown",				ID:        "job",			spec: JobSpec{			name: "unknown operation",		{		},			wantErr: true,			},				K:         150,				Columns:   []string{"x"},				Operation: OpPercentile,				ID:        "job",			spec: JobSpec{			name: "percentile out of range",		{		},			wantErr: true,			},				},					{Column: "x", Value: 1},				Conditions: []CategoricalCondition{				Operation: OpBinAvg,				ID:        "job",			spec: JobSpec{			name: "bin average without target",		{		},			wantErr: true,			},				Operation: OpBinCount,				ID:        "job",			spec: JobSpec{			name: "bin count without conditions",		{		},			wantErr: true,			},				Columns:   []string{"a"},				Operation: OpCorr,				ID:        "job",			spec: JobSpec{			name: "corr with wrong column count",		{		},			wantErr: true,			},				Columns:   []string{"a", "b"},				Operation: OpMean,				ID:        "job",			spec: JobSpec{			name: "mean with wrong column count",		{		},			wantErr: true,			},				Columns:   []string{"income"},				Operation: OpMean,			spec: JobSpec{			name: "missing id",		{		},			wantErr: false,			},				K:         90,				Columns:   []string{"risk_bucket"},				Operation: OpPercentile,				ID:        "job6",			spec: JobSpec{			name: "valid percentile",		{		},			wantErr: false,			},				},					{Column: "gender", Value: 1},				Conditions: []CategoricalCondition{				Target:    "income",				Operation: OpBinAvg,				ID:        "job5",			spec: JobSpec{			name: "valid bin average",		{		},			wantErr: false,			},				},					{Column: "gender", Value: 1},				Conditions: []CategoricalCondition{				Operation: OpBinCount,				ID:        "job4",			spec: JobSpec{			name: "valid bin count",		{		},			wantErr: false,			},				Columns:   []string{"income", "spending"},				Operation: OpCorr,				ID:        "job3",			spec: JobSpec{			name: "valid correlation",		{		},			wantErr: false,			},				Columns:   []string{"income"},				Operation: OpVariance,				ID:        "job2",			spec: JobSpec{			name: "valid variance",		{		},			wantErr: false,			},				Columns:   []string{"income"},				Operation: OpMean,				ID:        "job1",			spec: JobSpec{