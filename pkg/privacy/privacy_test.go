package privacy
package privacy

import (
	"testing"
)

func TestPolicyConfig(t *testing.T) {
	cfg := DefaultPolicyConfig()

	if cfg.KAnonymityThreshold <= 0 {
		t.Error("K-anonymity threshold should be positive")
	}
	if len(cfg.AllowedOperations) == 0 {
		t.Error("Should have allowed operations")
	}
}


















































































































































}	}		t.Errorf("Expected 1.0 or 1.5, got %f", transformed)	if transformed != 1.0 && transformed != 1.5 {	// Should round to nearest 0.5	transformed := result.TransformedVal.(float64)	result, _ := inspector.InspectNumericResult(1.23, "job1", "mean", []string{"x"})	inspector := NewInspector(&cfg)	cfg.RoundingMultiple = 0.5	cfg := DefaultPolicyConfig()func TestRoundingMultiple(t *testing.T) {}	}		t.Error("Second log entry should be job2")	if log[1].JobID != "job2" {	}		t.Error("First log entry should be job1")	if log[0].JobID != "job1" {	}		t.Errorf("Expected 2 log entries, got %d", len(log))	if len(log) != 2 {	log := inspector.GetAuditLog()	inspector.InspectBinCount(10, "job2", []string{"gender"}, nil)	inspector.InspectNumericResult(1.0, "job1", "mean", []string{"income"})	inspector := NewInspector(nil) // Use defaultsfunc TestAuditLog(t *testing.T) {}	}		t.Error("Mean should be approved")	if !result.Approved {	result, _ = inspector.InspectNumericResult(1.0, "job2", "mean", []string{"x"})	}		t.Error("Variance should not be approved when only mean is allowed")	if result.Approved {	result, _ := inspector.InspectNumericResult(1.0, "job1", "var", []string{"x"})	inspector := NewInspector(&cfg)	cfg.AllowedOperations = []string{"mean"} // Only mean allowed	cfg := DefaultPolicyConfig()func TestDisallowedOperation(t *testing.T) {}	}		t.Error("Should hit limit")	if err := inspector.CheckQueryLimit(); err == nil {	inspector.InspectNumericResult(2.0, "job2", "mean", []string{"y"})	}		t.Error("Should not hit limit yet")	if err := inspector.CheckQueryLimit(); err != nil {	inspector.InspectNumericResult(1.0, "job1", "mean", []string{"x"})	// First two queries should pass	inspector := NewInspector(&cfg)	cfg.MaxQueriesPerSession = 2	cfg := DefaultPolicyConfig()func TestCheckQueryLimit(t *testing.T) {}	}		t.Error("Cell 1,0 should be suppressed")	if _, exists := transformed["1,0"]; exists {	}		t.Fatal("TransformedVal should be map")	if !ok {	transformed, ok := result.TransformedVal.(map[string]int64)	}		t.Errorf("Expected 1 suppression, got %d", len(result.Suppressions))	if len(result.Suppressions) != 1 {	}		t.Error("Table should be approved (with suppressions)")	if !result.Approved {	result, _ := inspector.InspectContingencyTable(counts, "job1", []string{"gender", "region"})	}		"1,1": 80,		"1,0": 3, // Below threshold		"0,1": 50,		"0,0": 100,	counts := map[string]int64{	inspector := NewInspector(&cfg)	cfg.KAnonymityThreshold = 5	cfg := DefaultPolicyConfig()func TestInspectContingencyTable(t *testing.T) {}	}		t.Error("Should have suppression note")	if len(result.Suppressions) == 0 {	}		t.Error("Count 3 should not be approved (below k-anonymity)")	if result.Approved {	result, _ = inspector.InspectBinCount(3, "job2", []string{"gender"}, []string{"gender=1"})	// Count below threshold	}		t.Error("Count 10 should be approved")	if !result.Approved {	result, _ := inspector.InspectBinCount(10, "job1", []string{"gender"}, []string{"gender=1"})	// Count above threshold	inspector := NewInspector(&cfg)	cfg.KAnonymityThreshold = 5	cfg := DefaultPolicyConfig()func TestInspectBinCount(t *testing.T) {}	}		t.Errorf("Expected 1.23, got %f", transformed)	if transformed != 1.23 {	// With precision 2, should be 1.23	}		t.Fatal("TransformedVal should be float64")	if !ok {	transformed, ok := result.TransformedVal.(float64)	}		t.Error("Result should be approved")	if !result.Approved {	}		t.Fatalf("Inspection failed: %v", err)	if err != nil {	result, err := inspector.InspectNumericResult(1.23456789, "job1", "mean", []string{"income"})	inspector := NewInspector(&cfg)	cfg.MaxPrecision = 2	cfg := DefaultPolicyConfig()func TestInspectNumericResult(t *testing.T) {