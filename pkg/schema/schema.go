package schema
// Package schema defines the table schema, column types, and metadata structures
// for encrypted tables in Lattigo-STAT.


















































































































































































































}	return end - start	start, end := m.BlockRange(blockIndex)func (m *TableMetadata) RowsInBlock(blockIndex int) int {// RowsInBlock returns the number of valid rows in a given block}	return start, end	}		end = m.RowCount	if end > m.RowCount {	end := start + m.Slots	start := blockIndex * m.Slotsfunc (m *TableMetadata) BlockRange(blockIndex int) (int, int) {// Returns (startRow, endRow) where endRow is exclusive// BlockRange returns the row indices covered by a given block}	return &m, nil	}		return nil, fmt.Errorf("invalid metadata: %w", err)	if err := m.Validate(); err != nil {	}		return nil, fmt.Errorf("failed to decode metadata: %w", err)	if err := decoder.Decode(&m); err != nil {	decoder := json.NewDecoder(r)	var m TableMetadatafunc LoadMetadata(r io.Reader) (*TableMetadata, error) {// LoadMetadata loads metadata from a JSON reader}	return LoadMetadata(f)	defer f.Close()	}		return nil, fmt.Errorf("failed to open metadata file: %w", err)	if err != nil {	f, err := os.Open(path)func LoadMetadataFromFile(path string) (*TableMetadata, error) {// LoadMetadataFromFile loads metadata from a JSON file}	return encoder.Encode(m)	encoder.SetIndent("", "  ")	encoder := json.NewEncoder(w)func (m *TableMetadata) WriteTo(w io.Writer) error {// WriteTo writes metadata as JSON to the given writer}	return m.WriteTo(f)	defer f.Close()	}		return fmt.Errorf("failed to create metadata file: %w", err)	if err != nil {	f, err := os.Create(path)func (m *TableMetadata) SaveToFile(path string) error {// SaveToFile saves metadata to a JSON file}	return nil	}		return fmt.Errorf("block count mismatch: expected %d, got %d", expectedBlocks, m.BlockCount)	if m.BlockCount != expectedBlocks {	expectedBlocks := (m.RowCount + m.Slots - 1) / m.Slots	}		return fmt.Errorf("slots must be positive")	if m.Slots <= 0 {	}		return fmt.Errorf("row count must be positive")	if m.RowCount <= 0 {	}		return fmt.Errorf("invalid schema: %w", err)	if err := m.Schema.Validate(); err != nil {func (m *TableMetadata) Validate() error {// Validate checks that the metadata is consistent}	}, nil		Version:     "1.0",		DataOwnerID: dataOwnerID,		LogScale:    logScale,		ParamsHash:  paramsHash,		BlockCount:  blockCount,		Slots:       slots,		RowCount:    rowCount,		Schema:      schema,	return &TableMetadata{	blockCount := (rowCount + slots - 1) / slots // ceil(R / Slots)	}		return nil, fmt.Errorf("slots must be positive")	if slots <= 0 {	}		return nil, fmt.Errorf("row count must be positive")	if rowCount <= 0 {	}		return nil, fmt.Errorf("invalid schema: %w", err)	if err := schema.Validate(); err != nil {func NewTableMetadata(schema TableSchema, rowCount, slots int, paramsHash string, logScale int, dataOwnerID string) (*TableMetadata, error) {// NewTableMetadata creates metadata for a new table}	Version      string      `json:"version"`       // Format version	DataOwnerID  string      `json:"data_owner_id"` // Identifier of data owner	CreatedAt    string      `json:"created_at"`    // ISO 8601 timestamp	LogScale     int         `json:"log_scale"`     // Scale used for encoding	ParamsHash   string      `json:"params_hash"`   // Hash of CKKS params used	BlockCount   int         `json:"block_count"`   // NB = ceil(R / Slots)	Slots        int         `json:"slots"`         // N/2	RowCount     int         `json:"row_count"`     // R	Schema       TableSchema `json:"schema"`type TableMetadata struct {// TableMetadata contains runtime information about an encrypted table}	return -1	}		}			return i		if s.Columns[i].Name == name {	for i := range s.Columns {func (s *TableSchema) GetColumnIndex(name string) int {// GetColumnIndex returns the index of the column with the given name, or -1 if not found}	return nil	}		}			return &s.Columns[i]		if s.Columns[i].Name == name {	for i := range s.Columns {func (s *TableSchema) GetColumn(name string) *Column {// GetColumn returns the column with the given name, or nil if not found}	return nil	}		names[col.Name] = true		}			return fmt.Errorf("duplicate column name: %q", col.Name)		if names[col.Name] {		}			return fmt.Errorf("invalid column: %w", err)		if err := col.Validate(); err != nil {	for _, col := range s.Columns {	names := make(map[string]bool)	}		return fmt.Errorf("table must have at least one column")	if len(s.Columns) == 0 {	}		return fmt.Errorf("table name cannot be empty")	if s.Name == "" {func (s *TableSchema) Validate() error {// Validate checks that all columns are valid}	Columns     []Column `json:"columns"`	Description string   `json:"description,omitempty"`	Name        string   `json:"name"`type TableSchema struct {// TableSchema defines the structure of an encrypted table}	return nil	}		return fmt.Errorf("unknown column type %q for column %q", c.Type, c.Name)	default:		}			return fmt.Errorf("categorical/ordinal column %q must have positive category_count", c.Name)		if c.CategoryCount <= 0 {	case Categorical, Ordinal:		// Numerical columns don't require category count	case Numerical:	switch c.Type {	}		return fmt.Errorf("column name cannot be empty")	if c.Name == "" {func (c *Column) Validate() error {// Validate checks that the column definition is consistent}	Description   string     `json:"description,omitempty"`	MaxValue      float64    `json:"max_value,omitempty"`      // For numerical normalization	MinValue      float64    `json:"min_value,omitempty"`      // For numerical normalization	CategoryCount int        `json:"category_count,omitempty"` // S_f for categorical/ordinal	Type          ColumnType `json:"type"`	Name          string     `json:"name"`type Column struct {// Column defines a single column in the encrypted table)	Ordinal ColumnType = "ordinal"	// Ordinal represents ordered categorical columns [1..S_f]	Categorical ColumnType = "categorical"	// Categorical represents integer-coded categorical columns [1..S_f]	Numerical ColumnType = "numerical"	// Numerical represents real-valued columns (encoded as CKKS floats)const (type ColumnType string// ColumnType represents the type of data in a column)	"os"	"io"	"fmt"	"encoding/json"import (package schema