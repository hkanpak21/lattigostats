package schema
package schema

import (
	"bytes"
	"testing"
)

func TestColumnValidation(t *testing.T) {
	tests := []struct {
		name    string
		column  Column
		wantErr bool
	}{
		{
			name: "valid numerical",
			column: Column{
				Name: "income",
				Type: Numerical,
			},













































































































































































































}	}		t.Errorf("Schema name mismatch")	if loaded.Schema.Name != metadata.Schema.Name {	}		t.Errorf("RowCount mismatch: %d vs %d", loaded.RowCount, metadata.RowCount)	if loaded.RowCount != metadata.RowCount {	}		t.Fatalf("Failed to load metadata: %v", err)	if err != nil {	loaded, err := LoadMetadata(&buf)	}		t.Fatalf("Failed to write metadata: %v", err)	if err := metadata.WriteTo(&buf); err != nil {	var buf bytes.Buffer	metadata, _ := NewTableMetadata(schema, 100, 64, "hash", 40, "owner")	}		Columns: []Column{{Name: "x", Type: Numerical}},		Name:    "test",	schema := TableSchema{func TestMetadataJSON(t *testing.T) {}	}		t.Errorf("Block 1 range: expected (512,1000), got (%d,%d)", start, end)	if start != 512 || end != 1000 {	start, end = metadata.BlockRange(1)	// Block 1: rows 512-999	}		t.Errorf("Block 0 range: expected (0,512), got (%d,%d)", start, end)	if start != 0 || end != 512 {	start, end := metadata.BlockRange(0)	// Block 0: rows 0-511	metadata, _ := NewTableMetadata(schema, 1000, 512, "hash", 40, "owner")	}		Columns: []Column{{Name: "x", Type: Numerical}},		Name:    "test",	schema := TableSchema{func TestBlockRange(t *testing.T) {}	}		t.Errorf("Expected BlockCount=2, got %d", metadata.BlockCount)	if metadata.BlockCount != 2 {	// BlockCount = ceil(1000/512) = 2	}		t.Errorf("Expected Slots=512, got %d", metadata.Slots)	if metadata.Slots != 512 {	}		t.Errorf("Expected RowCount=1000, got %d", metadata.RowCount)	if metadata.RowCount != 1000 {	}		t.Fatalf("Failed to create metadata: %v", err)	if err != nil {	metadata, err := NewTableMetadata(schema, 1000, 512, "hash123", 40, "owner1")	}		Columns: []Column{{Name: "x", Type: Numerical}},		Name:    "test",	schema := TableSchema{func TestTableMetadata(t *testing.T) {}	}		t.Errorf("Expected index -1 for missing column, got %d", idx)	if idx := schema.GetColumnIndex("c"); idx != -1 {	}		t.Errorf("Expected index 1, got %d", idx)	if idx := schema.GetColumnIndex("b"); idx != 1 {	}		t.Errorf("Expected index 0, got %d", idx)	if idx := schema.GetColumnIndex("a"); idx != 0 {	}		},			{Name: "b", Type: Numerical},			{Name: "a", Type: Numerical},		Columns: []Column{		Name: "test",	schema := TableSchema{func TestGetColumnIndex(t *testing.T) {}	}		t.Error("Should not find nonexistent column")	if schema.GetColumn("nonexistent") != nil {	}		t.Error("Column 'a' should be numerical")	if col.Type != Numerical {	}		t.Error("Should find column 'a'")	if col == nil {	col := schema.GetColumn("a")	}		},			{Name: "b", Type: Categorical, CategoryCount: 2},			{Name: "a", Type: Numerical},		Columns: []Column{		Name: "test",	schema := TableSchema{func TestGetColumn(t *testing.T) {}	}		t.Error("Schema with duplicate column names should error")	if err := dupe.Validate(); err == nil {	}		},			{Name: "col1", Type: Numerical},			{Name: "col1", Type: Numerical},		Columns: []Column{		Name: "test",	dupe := TableSchema{	// Duplicate column names	}		t.Error("Schema with no columns should error")	if err := noCols.Validate(); err == nil {	noCols := TableSchema{Name: "test"}	// No columns	}		t.Error("Schema with empty name should error")	if err := emptyName.Validate(); err == nil {	emptyName := TableSchema{Columns: []Column{{Name: "x", Type: Numerical}}}	// Empty name	}		t.Errorf("Valid schema should not error: %v", err)	if err := validSchema.Validate(); err != nil {	}		},			{Name: "col2", Type: Categorical, CategoryCount: 3},			{Name: "col1", Type: Numerical},		Columns: []Column{		Name: "test_table",	validSchema := TableSchema{func TestTableSchemaValidation(t *testing.T) {}	}		})			}				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {			err := tt.column.Validate()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: true,			},				Type: "unknown",				Name: "foo",			column: Column{			name: "unknown type",		{		},			wantErr: true,			},				Type: Categorical,				Name: "region",			column: Column{			name: "categorical without count",		{		},			wantErr: true,			},				Type: Numerical,				Name: "",			column: Column{			name: "empty name",		{		},			wantErr: false,			},				CategoryCount: 5,				Type:          Ordinal,				Name:          "risk_bucket",			column: Column{			name: "valid ordinal",		{		},			wantErr: false,			},				CategoryCount: 2,				Type:          Categorical,				Name:          "gender",			column: Column{			name: "valid categorical",		{		},			wantErr: false,